++ Заметка Как Сопоставить Команды И Процедуры

Надо не пользователю заучивать команды, а наоборот - привязывать процедуры к естественным названиям работ, которые пользователь формулирует для себя перед тем, как начать их выполнение вручную.

Однако, по семантике, это очень простые команды. А более сложные РечевойИнтерфейс не потянет.
- Здесь, как и в быту, важен собственный опыт исполнителя, опыт позволяет ему расшифровать смысл простой команды применительно к текущей ситуации.

В GUI пользователь видит список возможных вариантов действия. И из него выбирает.

В РИ пользователь должен либо помнить (или угадать) название действия (текст команды), либо привести Оператор к этому действию через механизм уточняющих вопросов-ответов (уточняющего диалога).

Но уточнения требуют сужения предметной области, то есть, понимания семантики вопроса и семантики каждого из предлагаемых вариантов ответа.

Уточняющий диалог это вроде:
> Открой мою музыку
< Это место мне неизвестно. Что это такое?
> Это папка, которая содержит музыкальные файлы mp3
< Найдено три таких каталога: С:\Музыка, C:\Документы\Прочие файлы\День рождения, С:\Windows\System32\Sounds Какое из этих мест вы имели в виду?
> C:\Музыка
< Место Моя музыка сохранено в БД. Выполняю операцию Открой мою музыку...


+++Как установить соответствие между Запросом пользователя и Процедурой?

А) Найти соответствие между Запросом и Процедурой в БД.
Б) Установить соответствие с помощью семантического анализа Запроса и Процедуры (и Контекста).
- Запрос (с учетом Контекста) нужно превратить в набор Сущностей, описанных классами. Это должны быть действия и объекты/субъекты.
- Процедура уже должна быть описана как действие: Трансформация(арг1, арг2, ...) -->(рез1, рез2, ...), где арг и рез - Сущности, описанные классами.
-- для арг и рез нужно указать допустимые классы Сущностей. В зависимости от ситуации, можно указывать или один только базовый класс, или список классов.
--- это вроде КТА в тапп2: входные аргументы могут быть разных типов данных, выходные тоже, но есть проблема: тип данных результатов зависит от перегруженной процедуры, а та - от типов данных аргументов. Так что тут все сводится к перегрузке функции в обычных ЯП. Процедуры же надо создавать практически по одной на каждый вариант ее использования (каждую комбинацию классов аргументов и результатов). А не одну на всех, как я поверхностно это понимаю.
Это простой для реализации и сложный для понимания объем работы - по созданию всех этих вариантов одной процедуры. КТА был понятнее.
--- Тут еще единый граф методов из этих процедур напрашивается.
-- если Процедура допускает варианты количества аргументов или исполняемой функции трансформации, то эти варианты надо описать раздельными процедурами.

- Однако, и Запросы надо превращать в Сущности по шаблону, шаблон зависит от контекста.
Запрос надо соотнести с Шаблоном Запроса и по нему распарсить на Сущности.
-- Шаблон Запроса сейчас предоставляется Процедурой, и код Оператора должен просто определить, является ли данный запрос совместимым с данным Шаблоном Запроса. На этом первичная проверка семантики считается пройденной и Запрос разбирается на Сущности согласно этому Шаблону Запроса. Вторая проверка - проверка типов Сущностей - должна делаться внутри Процедуры. И если она не успешна, то Процедура отказывается от выполнения Запроса, и Оператор ищет следующую подходящую Процедуру. Если ничего не находит, пользователю выводится ответ "не знаю".

В итоге, предлагаемая система - строго типизированная схема, в ней важную роль играют классы Сущностей.
В ней нужен общий СправочникКлассовСущностей для классов операции, слов, аргументов, результатов, Сущностей.

Текущая схема Оператора - редуцированная от строго типизированной, и работает на авось, в общем-то.

Следует ли спроектировать эту полную схему для нового Оператора?
- Это зависит от свойств этой схемы. Что получится в ее применении?

