++ Тройной Слой Источника Данных

Изложение немного путаное, можно бы и четче описать.

Это идея реализации доступа к большой БД.

Вроде БД Вордс, которая содержит миллион записей  словоформ.
Всяких, редко и часто используемых.

Их слишком много для практической работы моих проектов, и в тоже время, желательно иметь их все, сколько возможно.
А еще БД Вордс серверная, запросы проходят медленно. Локальные кеши бы ускорили работу приложения, если запросы повторяются и нет последовательных переборов всего набора слов.


Поэтому предлагается такой тройной слой доступа к данным:

1. Приложение запрашивает свойства слова Собака.

2. Локальный кеш 1 слоя ищет слово Собака и возвращает его свойства.
- Если оно есть в кеше, отмечается его вероятность востребованности, оно возвращается немедленно.
- Если его нет в кеше, вызывается слой 2, который должен найти слово и вернуть его данные. Эти данные добавляются в кеш.
- Если кеш достиг предельного размера, из него выбрасывается самый старый элемент, который помещен туда первым (FIFO).
- Частота использования элемента кеша нужна для того, чтобы записывать ее в бд слоя 2, а то пока слово в слое1, слой2 не получает запросов, поэтому его частота использования в слое2 не изменяется.
- Когда слово удаляется из кеша, его частота использования записывается в БД слоя2. Вот так примерно получается работа с частотами использования слов.

3. Слой2 содержит локальную БД, в которой содержатся более-менее часто используемые слова. Слой2 имеет предел размера БД, если БД превышает этот размер, слой2 автоматически удаляет из нее слова с низкой частотой использования. Это тоже кеш, только среднесрочный.
- Когда слой2 получает запрос на свойства слова Собака, он ищет слово Собака и возвращает его свойства.
- Если оно есть в БД, отмечается его вероятность востребованности, оно возвращается немедленно.
- Если его нет в БД, вызывается слой3, который должен найти слово и вернуть его данные. Эти данные добавляются в БД слоя2.
То есть, такой же механизм, как и в слой1.

4. Слой3 это собственно большая БД словоформ. В ней не хранится частота использования слов. 
- Когда слой3 получает запрос на свойства слова Собака, он ищет слово Собака и возвращает его свойства.
- А если слово не найдено, он возвращает значение Не найдено, и в кеши верхних уровней ничего не записывается, так оно и возвращается приложению.   


Замечания:

- Проблема выбрать размер кеша слоя1 и слоя2. Если слишком маленький размер, то скорость работы падает. Если слишком большой размер, то памяти может не хватить. 

- Проблема оценить вероятность использования слова. Вообще, она зависит от процесса, где используются слова. Если это работа с текстом - кеши эффективны.
 
- Уже есть проблемы с этим тройным слоем:
Если приложению нужен поиск-выборка всех вариантов слова из всей БД, как ее реализовывать?
-выборка из 1 слоя-кеша не имеет смысла вообще.
-выборка из 2 слоя - локальной БД покроет только часто употребительные случаи.
- выборка из 3 слоя - самая точная, но и самая медленная и заполнена шумом - всякими вариантами, которые только зря захламляют выборку. 

- набор функций для такого кеша стандартный. Наверно. 
  Целесообразно реализовать его как один класс доступа к данным большой БД, с промежуточной БД и небольшим локальным кешем.
  - Сложность в том, что так можно реализовать доступ только к одной-двум таблицам БД. Ведь придется создать еще локальную БД слоя2 для тех же данных, что есть в бд слоя3. А еще, эта штука может хранить только одиночные записи таблиц. Связанные записи нескольких таблиц хранить в БД слоя2 - слишком сложно в реализации.

- Тапп вряд ли тут пригодится, он слишком медленный, чтобы использовать его в качестве БД слоя2. Разве что в случае, если БД слоя3 размещена в интернете, а данные настолько непредсказуемой структуры, что сделать под них локальную БД невозможно.

 
  

