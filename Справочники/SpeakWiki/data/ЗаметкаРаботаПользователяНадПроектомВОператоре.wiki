++ Заметка Работа Пользователя Над Проектом В Операторе

Работа пользователя над Проектом в Операторе.

Это, по сути, создание алгоритма на лету в процессе исполнения Проекта.
Команды поступают от пользователя, немедленно исполняются (как в интерпретаторе).
В остальном - это тот же Алгоритм.
В нем есть:
- операторы - команды пользователя.
 (а встречные запросы пользователю чем считать в таком случае?)
- глобальные переменные - Внешние Сущности с их названиями, вроде Темп.
- локальные переменные - временные, локальные Сущности внутри Процесса.

Вот их, локальные Сущности Процесса, надо создавать, изменять и удалять на лету.
Еще, их надо как-то обозначать: придумывать уникальные названия и указывать типы Сущностей.
С названиями как-то можно еще, это дело привычки и фантазии.
А вот типы Сущностей - как их указывать?
- Без типов Сущностей будет много ошибок при подборе операции для исполнения команды.
- помнить эти типы трудно. 
- поискать в заранее составленном Справочнике классов Оператора - тоже долгое занятие.


+++Как быстро и просто указать тип Сущности?
- при том. что я сам его не знаю, или не помню?
А) сразу в команде создания Сущности: 
- Создать временную папку Дуб.
- Создать список файлов изображений.
(Тут Оператор может запросить название для этого создаваемого объекта)

Б) Указать тип выделенной командой:
- Дуб это папка проекта Дуб.

Вообще, есть идея. См Скриптосинтезатор. 


+++Как в РИ описать локальную Сущность в некотором Процессе?
- сначала надо иметь сам Процесс.
- можно как в обычных языках программирования:

А) Сначала объявить, потом инициализировать:
int n;
if(A==B) n=1 else n=0;

Б) Объявить после получения:
int num = getCount();

С описаниями есть проблема: Сложные языковые конструкции не укладываются в формат команд Оператора.
Нельзя ввести в консоль описательную конструкцию из трех предложений как команду.
Все описания должны быть представлены в виде одиночных командо-подобных сообщений.

Если рассматривать Процесс как функцию в языке программирования, то:
Созданная в Процессе локальная Сущность часто становится Результатом Процесса.
Поэтому одна из локальных Сущностей может стать Результатом Процесса. 
Но какая именно - неизвестно без законченного Алгоритма.
Это обычно высоковероятно для тех локальных Сущностей, типы которых совпадают с типом Результата Процесса.
Поэтому для Процесса надо бы заранее описать типы Результатов.
Но это трудно сделать в ходе Процесса, и легко, но не нужно - после его завершения.
- короче, тут еще надо думать. Мысль кончилась у меня.  


+++Процессы для Оператора - написать небольшую теорию о Процессах и их Жизненном цикле.
- Процесс можно Начать или Возобновить, потом работать в нем, потом Остановить или Завершить.
- Надо запоминать состояние Процесса, и где-то долго хранить его, до завершения Процесса. 
  Это могут быть довольно большие объемы данных, если Процесс их конвертирует, вроде RDF-файлов, по 100Гб.
- Надо вести учет приостановленных, незаконченных Процессов, чтобы выбрать один для его возобновления и выполнения.
- Нужно иметь возможность останавливать Процесс, упаковывать его Состояние Процесса (данные Процесса, контекст Процесса) в архив. чтобы потом разобрать их на полезные результаты или удалить.
- для каждого Процесса надо заводить (выделить) папку, чтобы в ней хранить промежуточные данные и состояние Процесса.
- И надо заводить собственную Корзину (аналог корзины Винды), чтобы иметь возможность отменить удаление файлов и папок.
-- и надо делать бекапы данных перед их изменением, чтобы иметь возможность откатить сделанные командой изменения.
- Процесс в языках программирования - это поток исполнения функции.
   Процесс может являться частью родительского Процесса. То есть, вызовом функции. С аргументами и результатами.
  Такие вложенные Процессы - шаг к более лучшей работе Оператора, обучение в процессе деятельности, через наблюдение за пользователем. 
- для Процесса хорошо бы заранее определить тип Результата и условие завершения Процесса (?)



+++Идея Скриптосинтезатор
Идея в том, что Оператор все команды, получаемые для (в рамках) Процесса, должен обрабатывать так, чтобы превращать их в операторы скриптового языка и дописывать в скрипт Процесса. Но и исполнять при этом, конечно, их надо.
Пользователь вводит команды поодиночке, а Оператор их превращает в операторы Алгоритма и дописывает в скрипт Процесса. 
- В процессе превращения он запрашивает недостающие данные у пользователя, по мере выявления проблем.
- Такое создание Алгоритма Процесса из команд пользователя позволяет легко проверять контекст Процесса.
- Наверно, я просто лучше понимаю эту тему, когда она про Алгоритм, а не как-то еще. Алгоритмы-то я хорошо изучил.
- в таком Алгоритме не будет условных переходов  if-then-else, так как эти проверки и другой сложный анализ данных делает пользователь.
  Он и сам делает переход, выбирает дальнейший путь. 
  А в команды скрипта это не попадает. Разве что комментарии можно будет в скрипт вставлять, если пользователь это захочет сделать.
-- Поэтому такой алгоритм всегда будет линейным.
-- Можно просто повторять совершенные пользователем действия-команды, и Процесс получится автоматическим. 
   Так можно автоматизировать небольшие простые кусочки работы.
   Но это годится только для простых Процессов, в которых:
    - пользователь все делал командами Оператора, ничего не делал вручную сам.
    - пользователь не отрабатывал ветвления, то есть, не принимал решения, исходящие из результатов команд Процесса.  
-- Так как в нем нет кода анализа данных, а есть только последовательность команд, то выполнять его без пользователя можно только в простых случаях.
   Там, где не нужно анализировать результаты предыдущих команд и делать выбор.
-- из такого алгоритма можно сделать нормальный скрипт-алгоритм: в него надо вручную добавить анализ данных и условные переходы.
-- еще, можно сопоставить несколько Алгоритмов завершенных Процессов и статистически выявить Точки ветвления, в которых начинаются различия между ними. 
- Этот Алгоритм - своеобразный Лог работы Процесса, помогает восстановить контекст Процесса после остановки и возобновления.
  Особенно если хранить в нем и возвращенные операциями результаты.
- Это может быть частью системы Наблюдение-Действие для Исполнителя (В данном случае, Оператора)
-- многоагентный Оператор только усложнит проектирование такой системы. Одноагентный, как сейчас - проще для понимания и проектирования.





 