++ Спроектировать Движок Создания Усредненного Регекса

Для Оператор нужен механизм создания усредненного регекса для нескольких запросов.

Пользователь должен ввести несколько вариантов запроса для одной команды.
Механизм должен все эти варианты свести в один регекс, который срабатывал бы на эти варианты, и только на них.

Пример:

Скопируй файл Х в папку У
перемести файл Х в каталог У
помести папку Х в папку У
--------------------------
^[скопируй, перемести, помести] [файл, папку] Х в [каталог, папку] У$


Проблемы:
- пользователь должен ввести столько примеров, чтобы покрыть ими все пространство комбинаций вариантов запроса для 1 команды.
- при этом это пространство не должно пересекаться с пространством вариантов других команд. 
   Но определить это может пока только пользователь.
-- Хотя, код тоже может - ему нужны регексы других команд, чтобы определить, сработают ли они на один из введенных пользователем запросов.
   Если сработают, проверяемый запрос должен быть помечен как конфликтный. Об этом надо сообщить пользователю еще до генерации общего регекса.
   Но это годится только уже в движке Оператора, а как это сделать в тестовом прототипе генератора регексов? Никак.
   Никак. Только предусмотреть проверку и предупреждение пользователю сразу при вводе вариантов запроса.
   - и это будет жрать ресурсы компа, на проверку сотни регексов существующих команд.
   - и все ранво не прокатит -  там есть регексы, истинные для любого выражения - обработчик по умолчанию. 
     Он вызывается последним в очереди подходящих процедур. Что делает - не помню.
	 Поэтому можно только выводить список конфликтных процедур для введенного регекса, а пользователь должен сам решить, менять запрос или нет.
- короче, просто встроить механизм в Оператор не получится - придется его допиливать под Оператор и его БД команд.
   Сейчас неясно, как это делать.	 


Реализация: идеи

Каждый запрос надо разобрать на токены - словоформы, пути файлов, итп. 
Затем выявить повторяющиеся последовательности токенов и различающиеся последовательности токенов. 
Затем собрать регекс так, чтобы он был успешен для всех введенных вариантов.
И показать его пользователю.
А если регекс собрать нельзя, тоже нужно сообщить об этом пользователю.
А выявлять повторы токенов слева направо или справа налево или яхз как.

