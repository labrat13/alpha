++ Оператор Классы

Оператор классы
Есть интересные идеи и решения.

Сейчас процедура должна проверять классы мест и возвращать отказ, если место неподходящего класса. 
Это позволяет держать места разного класса с одинаковыми названиями.

Сейчас вроде бы проверки классов мест не делаются, классы мест не используются.

Можно сделать классы для процедур.
Описывать набор аргументов и их классы той же нотацией, что и классы мест. Заранее, в свойствах процедуры.
- Зачем?
-- Чтобы пользователь знал, что требует данная процедура. Это нужно, чтобы создавать новые команды со старыми процедурами.
-- Чтобы проверять соответствие типов аргументов до вызова процедуры.
--- Но процедура сама должна производить эти проверки типов. И возвращать отказ при неправильных типах аргументов. Зачем лишняя проверка?
---- Она позволяет отсеять процедуры сразу после выборки их из БД, но не запускать каждую из них для проверки.
---- Проверять аргументы процедур желательно, так как есть процедуры - внешние утилиты, для них эту проверку типов аргументов не сделать никак. 
     Там просто командная строка и в нее подставляются значения аргументов.
	 Но можно написать код-оболочку, он и будет проверять типы аргументов и уже потом запускать утилиту.
- Но это дополнительная работа, надо знать синтаксис записи классов процедур и аргументов. Лишняя сложность?
- Если положить, что первое слово в тексте запроса должно быть глаголом (или вопросительным: какой, сколько, когда, зачем, ...), то можно по этому первому слову сделать выборку процедур из БД.
  Сейчас там делаеся полная выборка из БД всех процедур, и потом отрабатывается регекс для каждой процедуры.
-- Значит, это первое слово описывает класс процедуры. Его надо хранить в отдельном поле таблицы команд в БД, чтобы по нему делать выборку.
-- Первое слово - глагол. А как быть с его формами, а с синонимами?
Вариант А) регекс команды должен быть типа:
^[создать, создай, нарисовать, нарисуй] диаграмму Х$
Код должен однократно распарсить регекс каждой процедуры, выделить синонимы этих первых слов. 
Затем создать и заполнить служебную таблицу первое слово -> ИД команды.
Потом по этой таблице делать выборку команд по первому слову из текста запроса.
--- Но это требует сразу правильного составления регекса. Это трудно.
--- Этот вариант - простой, формальный автомат, на ручном управлении. Нужно знать регекс.
Но это можно упростить, если регекс формировать кодом. Запрашивать у пользователя варианты первого слова сразу при создании процедуры. 
А лучше - запрашивать сразу несколько вариантов текста запроса, и из них формировать усредненный регекс.
Типа:
Скопируй файл Х в папку У
перемести файл Х в каталог У
помести папку Х в папку У
--------------------------
^[скопируй, перемести, помести] [файл, папку] Х в [каталог, папку] У$

---- Неудачный пример? сразу видны проблемы этого метода. Тут надо думать, что вводишь в качестве примеров. Скопировать и переместить - разные операции.
и не факт. что регекс будет работать. Хотя, можно проверить его на всех этих примерах, он должен для всех их работать. 
Но вот как проверить его на отсутствующих примерах, где он не должен срабатывать?
---- Это надо вынести эту фичу в отдельный проект - исследовать, как из нескольких запросов построить обобщенный регекс. Правильный. 
Чтобы потом встроить готовый механизм в Оператор и радоваться успеху.
--- Но все равно, надо знать, как это все работает, весь механизм Оператора. 
И это мешает распространять Оператор, так как его легко повторить, зная его устройство.
--- Этот вариант предпочтителен на сегодняшней стадии проекта.

Вариант Б) держать синонимы первых слов в лингвистической таблице, приводя их в первичную форму: 
создайте -> создать. 
И потом модифицировать этим текст запроса, по нему выбирать процедуры и пытаться их запускать, как сейчас делается.  
--- Это нужен слой пред-обработки запроса. Лингвистический процессор. Это позволяет его более приблизить к естественному диалогу.
Например, делать отбор процедур по текущему контексту работы, чтобы отметать варианты, интерпретации, лежащие вне контекста текущей работы.
А также, обрабатывать составные запросы вроде: Найди Х и отбери из них У. или Скомпилируй и запусти Х. 
---- А может, сделать его как нейронную сеть? На вход подаешь запрос, а на выходе он выбирает процедуру, которую надо исполнять. 
----- Это оригинально, но пока я не готов над этим думать. И обучать его надо, и ошибки будут возникать иногда. 
А компьютер с важными данными работает, неконтролируемые ошибки тут недопустимы. Нейросеть не годится в таких случаях, она допускает ошибки. Это ее свойство.
--- Это более сложный вариант, он требует собственного набора данных, опыта работы. Но он и более желательный в плане развития проекта.


У меня Оператор не так устроен. Сейчас команды и процедуры не разделены.
И вообще, тут путаница в терминах.
Команда - это вот запись в БД, которая содержит регекс и связанную с командой процедуру с аргументами.
Процедура - это или внешняя утилита или функция из набора функций Оператора, встроенная или загружаемая. 
Есть текст запроса, регекс каждой команды делает из запроса собственно команду, связанную с этой же процедурой, и набор аргументов.
Одна процедура может использоваться для нескольких команд. Но одна команда -> одна процедура. 
А гибкость - за счет перебора имеющихся команд, подходящих для запроса, при помощи регекса.

Однако, нужно дерево классов для процедур и мест, чтобы их правильно назначать и чтобы код мог проверять по нему, допустим ли аргумент по родительскому классу, по собственному классу.
Но это дерево нужно хранить, просматривать, редактировать (добавлять, удалять, перестраивать). Это в консоли делать неудобно очень. Нужен ГУИ, хотя бы в отдельной служебной утилите. Админской.
- Значит, для чисто консольного Оператора следует сделать ГУИ-утилиту администрирования? Мило.

Идея: Использовать Тапп в качестве БД Оператора.
- Тут нужна специальная встраиваемая реализация Тапп, а он сейчас сам себе цель.
- Тапп жрет память, так что только ячейки MCellA.
- Тапп должен экономить память компа, сейчас же он делается так, что сам ее всю занимает.
- Тапп должен иметь возможность самодиагностики и восстановления после сбоя, вызванного сторонними приложениями.
- Тапп еще не готов для этого. Его еще надо допиливать, чтобы вставить в Оператор в качестве замены БД.
- сначала надо встроить БД в Оператор, чтобы потом легко заменить ее на Тапп, один-к-одному. 
