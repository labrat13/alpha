++ Тема Философия РИ

Эта штука - Оператор - это коробка для технологий. В нее будем добавлять мои разрабатываемые штуки, чтобы единообразно в едином интерфейсе их использовать. 

* ОбщееПредставлениеРИ
* ЗаметкиНовыйВзглядНаПроцессВыполнения - todo: извлечь общую структуру системы и сущности для глоссария.
* ЗаметкаОРежимеРаботыКомпьютера
* ЗаметкаПредставлениеДанныхЧерезРИ
* ПримерРечевогоДиалогаЖелезныйЧеловек1
+++Куча новых заметок не всегда по теме
* ЗаметкаНеймспейсыКомандОператора
* ЗаметкаОтложенныеЗаданияОператора
* ЗаметкаАвтоматическоеПланированиеОператор
* ЗаметкаОператорКакИИ
* ЗаметкаОператорЧерезСмартфон
* ЗаметкаАбстрактныйРусскийЯзык
* ЗаметкаЗапросыПоискаКОператоруИКлассы
* ЗаметкаДругойСпособПриложений
* ЗаметкаИнтегрироватьОператорИВопросноОтветныйПроцессор
* ЗаметкаОператорКлассы - переработать
* ЗаметкаПочемуОператорНельзяПубликовать
    * ЗаметкаЧтоОператорМожетДелатьПолезного
    * ЗаметкаКакРазвиватьОператорБыстроЛегко
    * ЗаметкаНазванияДляОператора - распространение
    * ЗаметкаРаспространениеОператора
* ЗаметкаНадстройкаНадОС
* ЗаметкаДиалогиПроцедурОператора
* ЗаметкаЧтоДелатьЕслиПроцедураНеНайдена
* ЗаметкаСделатьОмонимыМест
* ЗаметкаОператорНакоплениеОпыта
* ЗаметкаОператорКритика
* ЗаметкаТестПеречисленияПриложений
* ЗаметкаНадоСделатьКоманды - философия
* ЗаметкаОбсудитьРаспознаваниеРечиСейчас - философия
* ЗаметкаРесурсыЗадач - философия
* ЗаметкаПроектыИПроцессыВОператоре - философия
* ЗаметкаТеорияИИ

+++Общее представление
Программа с речевым интерфейсом - Это программа для управления домашними делами.
Ее структура состоит из приемника голосовых [Команда], преобразующих в слова.
Потом консоль, в которую слова приходят так же, как и набранный пользователем  текст.
Результаты выводятся в эту же консоль, и потом озвучиваются как устная речь.
Затем парсер, потом уже разбор слов и выполнение работы.

Консоль, в которую набирается текст на естественном яыке с пунктуацией. 
Или без пунктуации, так как она в естественной речи не передается.

Скриптовую систему Инвентаря расширить до голосовой системы управления Инвентарем, планировщиком и вообще программами. И в таком виде все это подавать и использовать. Речевой интерфейс использовать как промежуточный слой для механизма скриптов. Такой проект - модуль - пакет технологий - для построения речевого интерфейса.

 Я пока не представляю себе, для чего мне это можно применить, пока нет голосовой системы, все это неуклюже.
Отдавать [Команда]ы можно будет набором текста, а потом просто голосом.
Вопрос, какие такие [Команда]ы, что они будут делать, чтобы вся эта работа окупилась?

Как это все должно выглядеть для пользователя? Я как пользователь набираю текст на обычном русском языке, только без знаков препинания и так, словно я его вслух произношу. Секретарь делает за меня на компьютере эту работу. Пока это довольно примитивно выглядит, надеюсь потом усложнится. Потом можно добыть денег и пикрутить распознавание голоса, и все будет тогда роскошно.  

Это все же не отдельная программа, а модуль-надстройка над собственно движком программы, подобно скриптовому движку, или подобно меню программы, исполняющая операции в программе. Просто благодаря гибкой структуре ее можно прицепить к разрабатываемой программе, чтобы получить дополнительные возможности. Можно навесить ее на уже какое-либо запущенное приложение, используя клавиатурный ввод в программу - для управления системой меню и вводом в контролы программы.

Это можно считать еще одним интерфейсом к модели [Задача]и в приложении. Соответственно, для лучшего использования нужно проектировать приложение специально под этот интерфейс.

Название: модуль речевого интерфейса ?


+++ Секретарь Способы Работы С Данными
Секретарю проще выполнить работу внутри своей структуры моделей, подобно человеческой памяти. Но в этом случае образуется чрезмерно большая модель, из-за большого объема перерабатываемых данных. Поэтому Секретарю следует хранить в памяти только методы и модели, необходимые для собственно обработки данных. А сами данные следует хранить во внешних источниках данных, например, в файлах, в исходном виде или их можно переработать чтобы привести в более удобный для обработки вид.

Хотя в некоторых случаях проще и удобнее хранить информацию прямо в виде графовых моделей, а не загружать ее из хранилищ.
Например, если предметы Инвентаря обрастут ссылками на другие сущности, то их лучше хранить в виде графовой модели. А если они остаются в рамках карточки предмета, то их проще хранить в виде массива записей БД, и распаковывать в графовую модель непосредственно перед использованием.
Частота использования как критерий выбора способа хранения: в графе или в массиве. Если часто требуется в виде графа, то и хранить в виде графа. А если редко требуется, то сжимать в массив и хранить в файле/внешнем хранилище.
Или сразу хранить в виде графа, но в отдельном контейнере - хранилище.

+++Обучение пользователем, требования к архитектуре. 
 
Если предполагается автоматизация [Задача] на компьютере. То как будет происходить обучение этого ИИ?   
Проще всего использовать наглядное обучение - наблюдение и повторение. Тут надо создать максимально схожие условия как для обучающего (пользователя), так и для обучающегося (ИИ). То есть, ИИ должен быть реализован в виде независимого от компьютера модуля, который так же, как и пользователь, может использовать те же средства.
Например, пользователь использует для выполнения [Задача] консоль, и ИИ тоже должен иметь возможность использовать такую консоль, и наблюдать за действиями обучающего (пользователя). То есть, получать ввод и вывод с его консоли.
Или просто использовать общую консоль? То есть, фактически получается такая необходимость создать независимую личность (ИИ), которая взаимодействует с личностью пользователя, который обучает его необходимым действиям. Таой диалог двух субъектов получается. И все это на основе однотипного интерфейса, в данном случае, интерфейса консоли командной строки. Предполагается, что пользователь будет выдавать [Команда]у-запрос и показывать, как этот запрос должен исполняться. То есть, он сразу будет показывать исполнение этого запроса и как это все выглядит.

(Это предполагает наличие структуры диалога, поддержание и управление диалогом для обоих участников диалога.
Эту структуру диалога над сначала разработать, потом обеспечить ее соблюдение участниками. 
Тут много работы.)

Тут нужен интерпретатор командной строки, интегрированный в консоль общения пользователя и ИИ.
 
Кроме того, ИИ должен быть достаточно независим от основного компьютера, чтобы его собственный поток восприятия не прерывался при ошибках в программе или при сбоях в работе компьютера. То есть, чтобы не было обратной связи. ИИ должен быть сторонним наблюдателем, чье состояние не зависит от состояния объекта управления. Иначе образуется обратная связь, которая будет портить весь процесс обучения.
Это что-то подобное серверу терминалов.

ИИ должен понимать не только что он должен сделать, но и что он получает в результате, чтобы формировать цепочки действий. Как он будет наблюдать результат - я понятия не имею, ведь результат - в основном это логическая модель, существующая в сознании пользователя, и отображающаяся с помощью ассоциативных связей на какие-то вполне раздельные и независимые данные, над которыми собственно и выполняются действия. И вся эта модель так и существует - в виде разнородных кусков, связанных вместе представлением пользователя, логической моделью в его голове. ИИ должен сам создавать и работать с такими моделями, чтобы выполнять хотя бы составные [Команда]ы.

ИИ также должен анализировать выводимые в консоль результаты. Как это сделать? 

Сама сущность этого ИИ - Секретарь. Пользователь запрашивает какую-то работу, Секретарь делает ее на компьютере. Поэтому ИИ можно назвать Секретарьом. Секретарь должен быть отдельным субъектом, отделенным от управляемой им системы, чтобы не возникало обратной связи. У него должно быть собственное непрерывное восприятие обстановки, чтобы можно было реализовать наблюдение. У него должна быть возможность выполнять действия. То есть, это его собственные действия, наблюдения за собственными действиями и за действиями других игроков, в данном случае, пользователя.
Соответственно, должна быть собственная память, в том числе память происходящего процесса, которой он мог бы запоминать и анализировать потом и какие-то шаблоны поведения выявлять и воспроизводить. Это все надо придумать и реализовать.

Названия: [Команда]а / запрос / текст запроса / поток запроса.
Названия: [Алгоритм] / действие / [Алгоритм] действия / поток действия.
Названия: пара запрос-действие, список запросов, список действий.

На первом этапе желательо вся эта система работать так: Она получила [Команда]у в виде последовательности слов.
Потом она ищет этот поток слов в памяти. Если не находит - запрашивает у пользователя объяснение в виде готовой последовательности действий. Или другую формулировку этой  же [Команда]ы. Затем она извлекает из памяти последовательность действий и выполняет ее. Затем возвращает результат. Если среди хранящихся потоков действий обнаружены нсколько одинаковых, то они объединяются в один, а потоки запросов собираются в этакий список синонимов - у одной последовательности действий получается несколько равнозначных последовательностей запроса.
Если для одной и той же последовательности запроса пользователь определяет несколько последовательностей действий, то это явно разные последовательности, и надо запросить у пользователя, чем они различаются и как их обозначать или различать.
И это все для условия, что в памяти просто тупо хранятся сами последовательности, и нет правил для их трансляции, трансформации и распознавания и вариативности поведения. А если будут еще и правила выбора вариантов, то все сильно усложнится.
Тут есть еще ряд вариантов и надо бы разработать [Алгоритм] или карту состояний для всех возможных ситуаций в этой области. И надо названия придумать для всех сущностей здесь и вообще в проекте. Как они выглядят, для чего нужны, как хранятся, как транслируются друг в друга, как выявляются общие последовательности, как анализируются. Как вообще производится работа с этими всеми сущностями.

И это все - наиболее эффективный способ создания системы, сосредоточиться на тупом повторении заранее запомненных действий, а потом уже навесить анализ. 
Как хранить эти последовательности? как пары запрос-действие? как запрос-связь-действие?



+++Система рефлексов
Это реакции на события.
Сам Оператор настраивать реакции не умеет. Это должен делать пользователь. 
КаналСобытий использует СписокКоманд. Такой же, как сейчас используется для отработки [Команда] от пользователя. Тоже с весом - порядком и приоритетом [Команда]. И так далее.
todo: Надо осмотреть существующий код прототипа и описать его структуру и функции. Именно устройство и работу.
[Команда]ы существуют отдельно от этого СписокКомандКанала (переименовать!) Приоритеты [Команда] (вес) работают внутри КаналСобытий, являясь свойством [Команда]ы внутри КаналСобытий, то есть, частью СписокКомандКанала, а не [Команда]ы.(Поле вес из [Команда]ы убрать, так как оно относится к КаналСобытий.)
Пользователю нужен АПИ для управления СписокКомандКанала для каждого КаналСобытий.
Пользователю нужен АПИ для управления самими КаналСобытий.
Надо придумать, как создавать новые КаналСобытий без перекомпиляции кода.(Уже есть идеи, но их надо увязать воедино.) Там нужен C#-код, чтобы ловить аппаратные события.
    * Можно реализовать КаналСобытий как подключаемый Модуль канала событий, и подключать его подобно вызову [Команда]ы, в процессе старта Оператора. Получится вроде плагина. C#-код мог бы запустить свой поток исполнения, чтобы в бесконечном цикле ожидания выполнять извлечение и обработку событий

+++Философские размышления
* Тут мне пришла мысль о том, что вся эта концепция есть развитие той концепции, что предполагалась для [Команда]ной строки еще первых компьютеров. Там тоже обещались диалоги с компьютером на естественном языке. Но потом процесс пошел в сторону ГУЯ, а диалоговый текстовый режим деградировал до bash с его сложным синтаксисом. Хотя, возможно, проблемы естественного диалога оказались серьезными, и развития не получилось. А потом началась деградация реализаций идеи - как проще, как быстрее. А может быть, проблемы изначально заключались в отсутствии технологий и производительности и объеме памяти компьютеров. Поэтому тему остановили, а потом использовали то, что осталось, по-быстрому, не напрягаясь. 
* Фактически, РИ заставляет пользователя использовать подвариант естественного языка для работы на компьютере.

+++Наблюдение РИ
* эти все [Процедура]ы надо выносить в скрипты, и чтобы их можно было запускать рекурсивно. Но и тут удобно то что используются разные словоформы для [Место]. А вот проверять семантику операции - это и есть интеллект. И еще КонтекстЗадачи. Пока у системы нет наблюдения за происходящим, это не получится достаточно полезная система. В нее надо передавать действия пользователя - например, открытие папки или запуск приложения. Хотя проблема в том, что приложение не знает, работает ли пользователь с программой или ушел, или просто его глючит.

+++Командный интерпретатор
Была идея сделать из этого проекта командный интерпретатор подобный cmd.exe. Но пока это сделать нельзя, поскольку сейчас нет КонтекстЗадачи. В интерпретаторе КонтекстЗадачи заключался в текущем каталоге, относительно которого вся работа и велась. Пользователь сам должен помнить, зачем он туда пришел и что он там делал ранее.
В моем приложении сейчас нет КонтекстЗадачи, и негде хранить эту строку текущего каталога.
А сама идея вроде хорошая, можно потом опробовать. 


+++О автоматизации работ
Для автоматизации работ часто надо лишь написать [Алгоритм].
Но под каждую [Задача]у нужен свой [Алгоритм].
Это похоже на разбор строки текста.
До изобретения регулярных выражений каждый разбор строки требовал написания собственного [Алгоритм]а. 
А с изобретением регексов нужно только правильно составить шаблон поиска. 
Для этого есть методика и утилиты для тестирования шаблона на примерах.
И необходимость такого тестирования.

Можно ли применить этот способ здесь?
Вместо того, чтобы писать [Алгоритм] на каждый случай, хорошо бы по методике составить некий текст, разобрав который, компьютер мог бы выполнить работу.
Правильность такого процесса пришлось бы отлаживать.
Часто работа нужна всего один раз. Поэтому такой механизм должен быть самотестирующим - он должен сам проверять работу построенного [Алгоритм]а и правильность его отдельных частей.
Как этого можно добиться?

++++Классификация сущностей
Итак, Оператор работает не просто с объектами, а с сущностями определенного типа. 
Каждая роль (место в [Алгоритм]е, обозначается обычно переменной) может быть описана требованиями к классу объекта, к содержимому объекта.
Это может быть не просто класс вроде int, а специальный субкласс, для которого объекты отбираются особенным образом, и который возможно нигде более в системе не применяется. 
Кроме этого конкретного куска [Алгоритм]а.
То есть, это такой кастинг объектов для этого класса. Не каждый подойдет.

Нужно обеспечить хранение объектов с указанием их класса. 
И обеспечить хранение классов и связей между ними.

++++Классификация операций
todo: Добавить текст сюда...


+++Почему не пошел РИ
РИ не пошел потому, что его максимальное число сущностей намного меньше, чем то, с которым я работаю сейчас.
Я сейчас работаю с десятком концепций, содержащих в общем несколько сотен сущностей. Такая работа предполагает бессмысленность запоминания имен сущностей. Я манипулирую ими как камнями в куче других, без учета их индивидуальности. А РИ предполагает, что сущностей немного и их легко запомнить. Эти два подхода не получается одновременно использовать. 
РИ тонет в остальной куче и не может быть обособлен ввиду отсутствия существенной функциональности.

+++Научить понимать текст
Надо научить Оператор понимать текст [Команда]ы. 
Это отражает большую часть мышления человека, которое частично и воплощается в речи.
При этом и контекст будет лучше изучен и будет лучше использоваться.
+++Сущности из файлов и папок
* Сущности - файлы и папки хорошо бы создавать на лету из собственно файлов и папок файловой системы. В тот момент, когда они нужны. Но вот папки коллекций вроде МояМузыка лучше забивать особо и сразу. Вручную или предустановленными - это надо решить, как удобно будет.
    * Вручную - значит [Место] создается пользователем с вводом всех свойств  как для любого [Место]а.
    * Предустановленным - [Место]о уже существует, заранее описано и создано, но его надо прицепить к папке в операционной системе. Это надо предложить пользователю на этапе развертывания и настройки программы. И пользователь мог бы это сопоставление отложить или совсем отключить это [Место]о. Если он не будет вести проекты, зачем ему [Место]о МоиПроекты?
        * Тут еще надо учесть, что эти папки не всегда соответствуют стандартным для ОС - в стандартных все криво сделано, и пользователи или предпочитают собственные папки, как у меня, или вообще держат коллекции в сети.
    * Это все будет ясно, когда к этим файлам и папкам будут идти запросы.
        * Но для этих запросов надо реализовать эти файлы и папки, или притворяться что они реализованы.
* Можно данные файлов и папок хранить в метаданных файла (NTFS только). Это замедляет поиск [Место], зато не надо синхронизировать БД при изменениях файловой системы. 
* Этих файлов и папок так много, что их не запомнить. Это обычная проблема РИ.
    * Тут можно попробовать использовать абстракции и нечеткие указания Сущностей.
    
+++Формы глагола в команде
[Команда]а обычно должна начинаться с глагола. Он должен быть первым словом в [Команда]е.
 * Глагол в первичной форме, Например, Открыть, удобен для написания скриптов, состоящих из множества [Команда].
 * Глагол в личной повелительной форме, Например, Открой, удобен для собственно пользователя. Хотя и им тоже можно писать скрипты, но они тогда выглядят не абстрактно, как обычно общепринято.
    * Но все же можно и писать скрипты - инструкции, и вводить так более естественно. Это надо привыкнуть, а мне сейчас не очевидно.
* Поскольку [Команда]а может использовать разные формы этого глагола, то нужно их обрабатывать.
    * На все глаголы, используемые в [Команда]ах, надо иметь и первичную и повелительную формы.
    * Надо подменять первичную форму глагола на повелительную, если [Команда]а не была распознана.
* Чтобы знать соответствие между формами глагола, вносим формы глаголов в словарь парами.
    * Поскольку словаря полного нет у меня сейчас, то вносим формы глаголов, запрашиваемые при создании [Команда]ы.  
* [Алгоритм] поиска обработчика [Команда]ы такой:
    1 принимаем текст [Команда]ы
    2 сбрасываем флаг замены глагола
    3 прокручиваем цепочку поиска обработчика [Команда]ы 
    4 Если [Команда]а не была распознана в общем порядке, то:
        5 Если флаг замены глагола сброшен и первое слово из текста [Команда]ы имеется в словаре форм глаголов, то 
            6 заменяем его на другую форму этого же глагола из словаря
            7 устанавливаем флаг замены глагола.
            8 переходим к шагу 3 - снова пробуем распознать [Команда]у в обычном порядке.
    * Иначе - сообщаем что [Команда]а не распознана, конец.  
    
+++Выделение чего-то из текста
Выделение чего-то из текста, зачем-то. Этот процесс предполагает, что я должен выделить некую слово или словосочетание как название, которое используется в текстах. Указать все его словоформы и затем произвести поиск этих словоформ во всех текстах документов. Причем эти тексты должны быть в той же вики-системе, и они должны быть доступны для поиска, сведены в некую совокупность страниц. Хотя фактически они разбросаны по разным вики- по проектам и прочим.  Для этой совокупности слов, обозначающих сущность, надо указать словоформы, и затем по этим словоформам находить упоминания в текстах и создать страничку-отчет со ссылками на все найденные упоминания словоформы. Потом мы на этой страничке напишем описание этой сущности, и это уже будет страничка термина, термином можно будет оперировать. Все эти словоформы в текущей вики нельзя задать для поиска - вики ищет определенное слово, а не все словоформы.
Так что нужна собственная вики-система, в которую надо перенести все документы. Кроме существительных можно искать и другие части речи. Тут можно использовать мою Words. Тогда из нее можно сразу получать словоформы а не ввродить их вручную. И наоборот, введенные вручную словоформы можно добавлять в базу слов и таким оьразом понемногу ее дополнять.
Для базы словоформ потреьбуется форма для ввода словоформ. Там нужно указать первичную форму, словоформы этой первичной формы. Потом можно было их сохранить в БД слов как куст словоформ и потом извлечь куст по любой из словоформ или по первичной форме. Эта форма должна вызываться из разных приложений.  Эта форма представляет собой форму, на ней расположены вкладки соответственно частям речи, и на вкладках контролы и кнопка получить из БД, записать в БД, очистить контролы. На каждой вкладке своя. Или с подключаемыми сменными обработчиками. Кнопка получить из БД моджет запускаться сразу же при запуске формы. Контрол первичной формы, контролы словоформ, куда надо ввести производные формы. контролы склонений итд итп. По нажатии на кнопку эти все свойства записываются в БД словоформ и используются для поиска по всем документам, ччтобы сразу создать ссылки на сущность, и свести таким образом все ссылки на эту одну страницу сущности. 
Возможно, можно просто изменить википад для реализаци такого поведения. У каждой части речи есть синонимы, эти синонимы надо как-то в это завести. Я часто путаю слова и не успеваю записывать мысли. Поэтому вместо одних слов у меня используются другие. Поэтому этот процесс надо отработать. Лучше всего сделать так, чтобы все сущности. Правило принять, чтобы все сущности в тексте были викифтицированы - были определены и привязаны к страницам словаря. Эти требования соблюдать каждый раз, тем более оно не очень надо - вот с этим проблема.    
    
+++Заметка о операторе
Моя жизнь состоит из тысяч небольших дел.
Купить эту работу я не могу - нет денег.
Если задачи не делаю я, их не делает никто.
Поэтому надо автоматизировать все что можно.
Чтобы уменьшить число работ, которые не будут сделаны.

Но это надо сделать так, чтобы эти автоматизации сами не превратились в кучу задач.
Чтобы в итоге количество задач уменьшилось, а не увеличилось.

Все мои программы теперь должны работать с Оператором.
Надо разработать методику такого взаимодействия.
Как Оператор может работать с программами вообще?
А) вызывать и передавать параметры через командную строку. 
- Принимать код завершения программы.
- Принимать результаты работы, сохраненные во внешних файлах
Б) изменять данные программы через специальный АПИ.
В) изменять данные непосредственно в файле, не запуская программу.
Г) отправлять окну программы сообщения и симулировать нажатия клавиш.
Метод В зависит от версии программы и может совершенно испортить данные.
Метод В очень трудоемок для чужих программ.
Метод Б трудоемок для чужих программ. 
Метод А зависит от версии программы.
Метод Г удобен для чужих программ, но зависит от версии программы.

В следующей версии надо бы реализовать исполнение скриптовых файлов в качестве [Команда].
Скриптовый файл состоит из [Команда] Оператору, собранных в [Алгоритм] подобно пакетному файлу.
Скриптовый файл можно назначить вместо исполняемоо файла в [Процедура]е.
Ему передаются параметры из [Команда]ной строки. 
Внутри скриптового файла эти параметры подставляются в нужные [Место]а.  
Можно их как переменные представить.
Скриптовый файл может содержать переменные ? и переходы на метки? И условные переходы?
Или пока не будем это делать, а просто тупо последовательность [Команда] исполнять?
Это все вообще надо для того, чтобы подготовиться к внедрению скриптов как исполнителей [Процедура].
А потом надо будет семантический анализ [Команда] сделать.
Сейчас я просто не могу представить себе, как установить соответствие между словоформами и дейсвиями, сущностями, условиями.
Как это соответствие записать. Как это соответствие сохранить в БД. 
Как транслировать текст [Команда]ы в комплект действий, сущностейи условий. 
Сейчас я пока собираю тексты [Команда] как материалы для такого анализа. 

Тут получается такая штука: или я делаю библиотеку функций кода для использования их внутри сборок [Процедура].
Или я делаю повторное использование [Команда] Оператора в виде скриптов и вызовов [Процедура] из кода.
Но в любом случае, мне придется использовать студию при работе с Оператором.
Так как это не интерпретатор, поэтому я должен скомпилировать проект после внесения изменений.
С# дает мне доступ к функциональности операционной системы, который я не получу из языков-интерпретаторов.

+++Как представить концепцию как объект?
Это не совсем ответ на заданный вопрос, это попытка приблизиться к решению.

Это сейчас применительно к подсистеме лога Тапп.
Пока можно только представить ее как некий безразмерный блок, в который приходят [Команда]ы от других частей Тапп. И обратно идут ответы.
Это такая функциональная схема запросов-ответов.
Ее трудно представить сразу - мощности ума не хватает.

Была идея это делать чатом: Один человек пишет в чат запросы, как в самом Тапп. А другой отвечает на запросы или сам запросы делает. Такой вот диалог. Но у меня нет двух человек.

Можно попробовать сначала записывать текстом все [Команда]ы, поступающие в модель подсистемы. Пронумеровать их. Потом ответы на них записывать.
Хотя можно и сразу записывать возможные ответы.

Важно, что надо полностью сделать эту работу. Нельзя недоделки оставлять. А то там и так непоняток много в общей структуре модели Тапп.

В итоге получится Функциональная модель подсистемы в части интерфейса с остальными подсистемами. Потом по ней проще будет придумывать внутреннюю организацию подсистемы.

+++Оператор организация
Оператор мог бы использовать не прямое соответствие Запрос-Операция, как сейчас, а более сложное, создающее промежуточную среду, в которой осуществляется выбор операции исходя из контекста и запроса.
Но такая работа регулярно будет создавать ситуации, в которых эти операции будут выбираться неправильно. 
Даже если пользователь наблюдает за ходом такой операции. То есть, ему надо вывести описание принимаемых Оператором решений, граф [Алгоритм]а, для контроля выполнения. И все равно, пользователь не сможет заметить мелкие особенности работы. 
Поэтому  изменения, которые вносит выполнение операции, нужно иметь возможность откатить.
Это важная фича для Оператора, и ее надо дополнительно обдумать.          

+++Методы путем наблюдения.
Методы запускаются через чат. Когда они запущены, они выдают некий текстовый результат, или же они просто выполняют какие-то изменения. Если они выполняют изменения, то их смысл описывается как изменение состояния некоего объекта. Для тоо чтобы система могла самостоятельно манипулировать объектом, его надо описать, представить во внутренней памяти Оператора, и соответственно связать его с этой [Команда]ой-операцией. Старое и новое состояние и сопутствующие штуки. Используя модели Тапп24. А если программа выдает какие-то данные, исходя из которых, считается что операция завершена успешно или неуспешно, то вывод программы надо анализировать и вытаскивать оттуда необходимые результаты. (Пользуясь абстракцией математической модели [Задача]и, нужно получить из этой модели требуемый результат согласно [Задача]е. В то время как программа (например, netcat) часто просто выдает данные для пользователя, который сам проводит их анализ для своей [Задача]и и принимает решение. Такую модель надо свести к выдаче только требуемых сведений, лучше всего свести к Да/Нет)
Например, из netstat нужно получить IP компьютера. И сделать вывод: есть IP, нет, какой и зачем и куда его применить. Почему он такой, а не какой-либо другой. И этот вывод програмы надо очистить и привести к необходимому для операции виду результата. Как это будет делать Оператор? Пользователь - понятно. Он прочитал в инструкции, что должно быть и где, что-то похожее увидел нечеткой логикой совместил и что-то как-то там дальше. А как этодолжен сделать оператор при отсутствии у него нечеткой логики и невозможности отказаться от выполнения [Задача]и? Придется этот вывод программы как-то парсить, вытаскивать из него полезные данные, повторять ту же работу, которую делает пользователь, когда ему не пофиг на результат. Пользователь работает по определенной методике, и Оператор должен работать по ней же, чтобы извлечь из вывода консольной программы данные для своей [Задача]и. Извлечь результаты и провести с ними определенные операции. То есть, ему нужен такой метод, который будет ванализироваь вводимую информацию и выделять из нее требуемые данные, распределяя их по именованным объектам со смыслом, чтобы в дальнейшем ими распоряжаться и их использовать. Часть из них потребуется, часть не потребуется. Универсальный парсер получается. А если не универсальный, то я заебусь под каждый вывод программы делать собственный парсер. И прицеплять его и отбирать итд.  
Возможно, проще будет распарсить исходники программы - [Команда]ы и выдрать из них требуемые для [Задача]и блоки, превратить их в [Алгоритм] для внутреннего исполнения и исполнять в интерпретаторе. И сразу уже иметь эти самые результаты, готовые, которые не надо извлекать из текста. (То есть, интерпретатором исполнять исходные коды) Но это процесс сложный, его реализация займет много времени. Исходники сейчас неполные и там очень много сторонних библиотек используется. И особой выгоды это не дает. Проще написать парсер вывода программы, чтобы получать из него требуемые данные. И надо как-то собирать весь вывод программы отдельно от ввода и отправлять анализатору для раздербанивания. Особенно это  сложно, когда в приложении используется диалоговый режим и пользователь должен отвечать на вопросы приложения.
В итоге получается такая система, которая сожрет несколько месяцев работы, если не несколько лет, в результате она будет в состоянии следовать указаниям по выполнени досчтаточно простой и непритязательной работы. Зато работы по разработке этой системы будет просто море. А нам надо как-то этот процесс улучшить.    

Поскольку объем работы большой, и большая ее часть совсем не творческая, то следует сосредоточиться сначала на маленьком прототипе, который должен выполнять часть работы по созданию следующих прототипов. Таким образом, нужно создать простое средство, чтобы несколько автоматизировать работу над проектом. Сейчас мне все приходится самому пилить. (Надо просто поставить цель и описать как это должно делаться. Тогда будет проще выделить ресурсы и довести это до результата. А сейчас это только наброски и они так и лежат набросками.) 
Вероятно, этот механизм консольный изначально предполагал такой вот процесс создания [Команда]ных файлов, которые на каждую [Команда]у пользователя чего-нибудь там выполняли бы. (Изначально в консоли каждая [Команда]а была отдельной программой. Это потом уже их собрали в одну программу и добавили условия и циклы. )
Прямо такая система из [Команда]ных файлов, которые друг друга вызывают и в итоге делают требуемую пользователем работу. Линуксоиды, в большей своей части, создают эту вот систему командных файлов, чтобы получить что-то вроде интеллекта для выполнения своих работ. Теоретически, кто-то из них должен был бы поделиться такой армадой командных файлов, но что-то этого не заметно. Похоже, эта идея консольная не получила должного развития. Эта система автоматизации используется отрывочно и бессистемно. И сами консольные терминалы недостаточно хорошо поддерживают такую работу. Недостаточные сркедства для выявления и обработки ошибок. Хотя вот появился перл, на котором можно это делать. Там можно делать такие скрипты. Это позволяет создать такую систему, но при помощи собственноручного написания кода.
А у нас комбинация перла с прологом или еще чем-то таким. Я все их не помню, мне не интересно что они там делают. Из пролога можно было бы что-то позаимствовать.
В общем, мне надо наускать ИИ на выполнение части работ по проектам. Опять же есть проблема интегрировать оператора и студию - среду программирования, которая у меня используется для работы над проектами.  

+++Оператор как часть ИИ
Оператор ориентирован на действия. 
Ему нужны сущности, чтобы распознавать их в [Команда]ах
Ему нужны типы сущностей, чтобы распознавать сущности в [Команда]ах точнее.
Но все это не ИИ. Этот механизм нельзя обучить - он не накапливает знания о выполненной работе. Можно только самому реализовывать его единицы поведения, написав скрипты.

+++Работа с сущностями
 При работе с файлами есть проблемы, не позволяющие сделать эту работу столь же интенсивной и простой, как с ГУИ.
- надо как-то указывать имена файлов в операциях.
  - имена файлов часто содержат лишнюю информацию - дату, номер версии и прочие свойства. Такие имена удобно просматривать в списке файлов. Но неудобно вводить вручную. Особенно это в Линуксе.  
  - вообще вся работа с файлами плохо приспособлена для интенсивного использования. Тут все так, словно это раз в месяц происходит, и времени на это выделяется с огромным запасом.
- при РИ имена файлов должны быть короткими и семантически рациональными.
- вот типа задача: в папке есть куча файлов, мне надо переместить три из них в другую папку.
  - в ГУи я их открываю в Проводнике, отмечаю и переношу в требуемую папку.
  - в РИ я должен их именами описать и при этом могут быть ошибки.
    - можно отметить их как-либо. Я сначала должен эти файлы видеть, просматривать каталог.
По памяти не получится - слишком много файлов.
По общим названиям - вроде Мой любимый плейлист - там немного будет таких сущностей, которые я могу запомнить. Хотя я смогу тогда помнить только их имена, а не в какой папке они лежат. Это тоже память, только другая. Неизвестно, какая проще.    
Сейчас все это разнообразие и файловое богатство основано на том, что пользователю показываются списки файлов, и он с ними работает. Эти списки ему заменяют память, он на [Место]е ориентируется. Каталоги используются как классификаторы сущностей. Поэтому и работа идет интенсивно.
РИ в этом плане плохо пригоден. Он сведет все к списку из 7 элементов.
- Можно совместить РИ как [Команда]ы и ГУИ для просмотра. Это сложно, но надо обдумать.
- Надо разделить [Задача]и, для которых пригоден РИ и [Задача]и, для которых нужен ГУИ.
  Их не нужно смешивать. 
РИ хорош для [Задача] работающих с одиночными именованными объектами. 
ГУИ хорош для работы со множеством объектов.
- Память на самом деле используется для запоминания [Задача], соответствующих им папок, состояния [Задача]и. И вообще, для хранения знаний об общей организации информации на компьютере, и в остальном мире. Вот надо бы эту общую организацию осмотреть и оптимизировать.
  - как ее можно оптимизировать? 
    - Можно применить стандартные методики оптимизации, только их надо найти и переложить на эту область.
    - для начала, я быстро осмотрел существующие проекты и собрал стандартную структуру каталога проекта. Теперь все новые проекты должны будут иметь единую систему папок и их не надо будет помнить для каждого проекта. Это должно сэкономить память немного.
      - надо перевести существующие проекты на эту новую схему. Но тогда все уже созданные ссылки-ярлыки попортятся, и их тоже надо будет переделывать. 
  - как ее можно осмотреть? Это ведь отдельная тема для работы. С собственной теорией и собственными заметками.

+++Классы в РИ
Взято из ТемаМеста 18.03.2017 0:03:11 - может и тут пригодится?
Это классы [Задача]? Или классы сущностей? Или [Задача]и это namespace?
* Класс это сущность, описывается существительным. Класс содержит сущности - переменные и функции-процедуры. Переменные класса представляют свойства сущности, представленной классом.
* Это не совсем то что нужно.
[Задача]а должна быть представлена [Алгоритм]ом. [Алгоритм] содержит сущности и действия. Но концепция класса здесь не подходит.
* В то же время, [Алгоритм] является контейнером для сущностей и действий. Вот как бы их, класс и [Алгоритм], скрестить?
* Теоретически, [Алгоритм] поддерживает и абстракцию, и инкапсуляцию, и полиморфизм.
* Абстракция [Алгоритм]а: он состоит из абстрактных [Алгоритм]ов. Вроде [Алгоритм]а абстрактной функции класса, который состоит из абстрактных типов данных и абстрактных функций других классов.
* Надо бы эту тему по [Алгоритм]ам поставить в общий план разработок.

++++Типы объектов в Хранилищах
В Хранилищах надо хранить также типы объектов, чтобы эти АПИ-пользователи могли их использовать.
Без типов сущностей все эти объекты в Хранилище - неведомые инопланетные артефакты. 
Оператор не может их различить и работает с ними в меру своих знаний. 
То есть, делает только то, что требует скрипт или пользователь.

Классу объекта сопоставляются действия. Они определяют и возможность выполнения действий, и конкретную реализацию действия.
Но это долгая тема.

++++Классы сущностей
Классы сущностей нужны не только [Место]ам, но и [Процедура]ам.
Например Документ::Журнал::МоделистКонструктор  это класс для журналов Моделист-конструктор в ХранилищеДокументов.

При обращении к хранилищу за документом можно получить также и его класс и соответственно искать или управлять документами.

Оператор не может хранить много [Место], поэтому сущности должны храниться в каталогах ХранилищеХххх.
А вот сами каталоги уже можно считать [Место]ами-контейнерами сущностей, поскольку их немного.
И Оператор мог бы работать с сущностями, находящимися в этих каталогах.

Класс журнала:  Журнал<Статья> : МоделистКонструктор<СтатьяМодель>
Журнал это контейнер для статей.
Статьи бывают разных видов (классов). Журнал может содержать статьи разных классов.

Эти типы и их иерархию, всю эту классификацию нужно держать в Справочнике.
А объекты этих классов в соответствующем Хранилище.

Создание таких каталогов и системы классов, определение операций с ними, общая оптимизация использования этих типов были бы общественно полезными результатами проекта.
Особенно если эти каталоги будут наполнены реальным содержимым.
Но такого содержимого у меня нет. Не могу же я использовать нелицензированный контент. 

++++Отношение агрегации
Как путь, вложенность контейнеров записывается через точку:
Журнал Моделист-конструктор.1996.№1 - пример по имени объектов
Журнал.ГодоваяПодшивка.Экземпляр (или Выпуск?) - пример по имени классов

В записи классов я сейчас использую : для обозначения отношения классификации и между классами и между классом и объектом.
Это неправильно. Отношение между классами это отношение классификации. А отношение между классом и объектом - отношение инстантиации.
- Отношение агрегации типично обозначается точкой.
- Отношение клаассификации типично обозначается :
- как обозначать отношение инстантиации? Я вот как раз его использую сейчас в РИ: Журнал<Статья> : МоделистКонструктор<СтатьяМодель>
Мне тогда надо парсер классов переделывать. Хорошо, что он пока не развит, и это достаточно просто сделать. В этом польза первых прототипов.

Но из-за того, что я долго это вообще не разделял, мне трудно отделить отношение классов от отношений класс-объект. И я их путаю при описании класса сущности.
А неподготовленный пользователь вообще не сможет ничего сделать правильно. И превратит всю систему в кучу мусора.

Можно предложить разработать структуру классов заранее и предлагать пользователю ее использовать.
- а кто будет ее разрабатывать? Академия наук?
- а кто будет ее использовать и где? Я, конечно. Кто же еще.
- а какой мне от этого толк? Меньше работы при использовании и обслуживании всего этого объема информации.

Получится этакая глобальная БД. А где взять ресурсы на ее содержание?

Библиотека полезна тогда, когда она используется. А я пока не использую ничего из нее.

Я не могу собирать иерархию классов без хранилищ объектов этих классов. 
Сначала надо сделать и наполнить хранилища сущностей, а потом уже придумывать и совершенствовать структуру классов этих сущностей.
Но это надо делать, а не тянуть резину. Время идет, а результатов нет. 


+++Сомнения о проекте
Вся эта штука выглядит рискованно ненужной.
-Чтобы выполнять работы, нужно помнить команды и что они делают. 
-Чтобы правильно выбрать команду, нужно знать, что она делает.
-Это все приведет к тому, что можно будет выполнять только более простые работы, чем сейчас.
Хотя обучаться им мне будет проще, так как они оперируют понятиями естественного языка и быта.
А более сложные процедуры придется выполнять через интерпретатор скрипта. Скрипт придется сначала читать, чтобы понимать, что процедура делает. 
Это получается, я при выполнении работ работаю в основном со скриптами, как программист, но на естественном языке. И так же нужна коллекция процедур (АПИ) с их описанием, как сейчас МСДН.
Достоинство только в том, что это все на естественном языке, и то - на первых порах это все же будет очень формальный язык. 

* МногозадачностьСекретаря
+++Представление о устройстве Оператор
Оператор должен не просто запускать программы - он должен выполнять вычисления и оперировать данными самостоятельно. Это что-то вроде большого интерпретатора, соединенного  с хранилищами данных и хранилищами методов обработки данных.
Конечно, я не могу сам все это делать, я должен использовать уже существующие утилиты и программы, веб-сервисы итд. Это все слишком сложно. Но тогда получается, Оператор это некий скелет, на который навешиваются различные скрипты, шлюзы к другим сервисам, созданные пользователем скрипты-методы, итд. И вот эту всю систему надо поддерживать, устранять конфликты, проверять правильность вычислений итд. Это работа на много тысяч человеко-часов. Это сегодня для меня неприемлемо.
Надо думать что-то другое. Надо что-то такое, чтобы я мог, ежедневно работая с Оператором, выполняя в нем свои задачи, этим самым улучшать его. А сейчас это просто набор скриптов и соотношений между сущностями, который я еще должен вручную создавать, отлаживать и поддерживать.
Вообще, сейчас Оператор очень примитивный даже как концепт.  
- Это надо разработать такой концепт, чтобы сущности, отношения и сами скрипты создавались как следствие выполнения моих работ в Операторе. И затем их можно было повторить, воспроизвести и анализировать или хотя бы просмотреть лог. Это что-то из проекта лент. И Тапп.
--Тогда я смогу наращивать Оператор по мере работы с ним, и иногда добавлять ему данных и методов целенаправленными заливками найденных и переработанных мною коллекций. 
- Оператору нужен интерпретатор для исполнения методов, которые он выполняет для пользователя. Чтобы пользователь мог создать новый процесс, отладить его и сохранить в Операторе. А потом при необходимости модернизировать. И таких процессов должно быть много. И они должны считаться именно процессами, своей терминологией.



+++Оператор как точка входа в автоматизацию
Оператор можно рассматривать как точку входа в процессы автоматизации моих работ.
Сейчас Оператор даже не работает - требуется новый прототип.
Существующий прототип поддерживает всего несколько команд, и не делает ничего полезного, и поэтому мною не используется.

Но вот концептуально - Оператор должен стать точкой приложения моих усилий по автоматизации.
Завести на него все мои эти Хранилища итд - надо опробовать.

Традиционная система меню приложений - где пользователь выбирает функцию для исполнения - информативна. Но она не позволяет развивать систему. РИ позволяет накапливать запросы пользователя и затем пытаться реализовывать их исполнение. 
Эта схема позволяет развивать систему для лучшего соответствия потребностям пользователя.
Хотя, по-прежнему, код писать придется мне самому.

Проблема в том, что пользователь должен помнить объекты - элементы, составляющие его рабочее окружение.
В графической среде он эти элементы видит - как объекты, ярлыки, пункты меню.
В РИ Оператора он либо должен помнить, как называются эти элементы - объекты, либо запрашивать списки объектов по некоторой теме или признаку и выбирать из них нужный объект или несколько объектов.
Также, в РИ он может просто использовать обычный свой лексикон, работая с объектами в каждой предметной области, используя шаблонный набор общих фраз и речевых конструкций. Без интеллекта этот набор будет довольно простым, а его развитие упрется в неоднозначность семантики речи. 
Для работы интеллекта же нужна развитая система классификации объектов. Ее создание - работа сложная, и ошибки в ней выявляются не сразу, долго и трудно. Это требует от пользователя высокой квалификации в определении классов объектов. В целом, предположительно, надо очень много времени потратить на классификацию каждого объекта рабочей среды, и импорт этой классификации из внешних источников.
Поэтому хорошо бы эту классификацию как алгоритм, как процесс, проработать и автоматизировать. Это и разгрузит пользователя, и позволит сосредоточиться на других частях проблемы РИ.

2 июня 2018 г. 20:45
То есть, исполнение запросов сейчас реализовано будет криво, и весь этот процесс малофункционален.
Но при работе будет происходить накопление текстовых запросов и реализаций процедур по ним.
А затем можно будет создать более интеллектуальный обработчик этих запросов и исполнитель процедур.
То есть, приблизиться к пониманию текста, вроде ИИ. 
И накопить библиотеку процедур для работ на компьютере. 
Этот процесс, как ожидается, будет очень длительным.
И поэтому сейчас надо интенсивно использовать Оператор, несмотря на его убогость на данном этапе.
После накопления опыта работы, текстов запросов, коллекций объектов и процедур, будет гораздо проще представить себе, что можно сделать из этой кучи.
Сейчас можно предположить, что я смогу получить исполнителя, которому достаточно будет текстового описания процедуры, чтобы ее самостоятельно реализовать, опробовать и выполнить работу.
Это будет подобие ИИ-секретаря с текстовым интерфейсом.












+++Историческая часть - с чего начался проект РИ

Надо преобразователь предложения-команды в строку-вызов приложения.
Что-то вроде русского Бейсика:
Запустить Ворд - Execute(Word.exe)
Открыть Блокнот -  Execute(notepad.exe)
создать заметку - Execute(notepad.exe)
Создать заметку "Заметка1" - Execute(notepad.exe %1)

Для этого нужны образцы строк запросов. Где их взять?
-можно просто собирать эти запросы вручную.
--а не хочется - они же не будут исполняться. Поэтому и вводить я их не буду - лень.
-можно писать на русском языке программы автоматизации задач на компьютере, как псевдокод.
И понятно, что делать, и примеры строк запросов.
-можно сразу сделать приложение, которое собирает запросы и исполняет их по мере возможности. Такая моя собственная консоль. Ею я наверно буду пользоваться - она ведь работает.
--практически нет, я ее сейчас сделал, но не пользуюсь, так как там мало возможностей.

Как организовать обработку строк запроса?
а) прямо сопоставить [слово] [слово] [слово] = действие
б) статистически выявлять и группировать запросы, обнаруживать стабильные обороты речи и аргументы - как это сделать?
в) распарсить текст запроса на лексемы, пронумеровать их и потом искать совпадение с шаблоном, вроде:
Копировать %1 из %2 в%3

Вообще же, либо имена сущностей надо делать короткими и удобными для использования, либо эта система будет использоваться только в скриптах. Сейчас значительно проще кликнуть по ярлыку, чем набирать Открыть файл С:/Мои документы/заметка1.txt
Хотя вот ярлыков слишком много получается, особенно для операций.

