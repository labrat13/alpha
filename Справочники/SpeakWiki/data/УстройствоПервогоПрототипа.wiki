++ Устройство Первого Прототипа
Здесь нужно описать устройство первого прототипа с комментариями и замечаниями.

В целом, код довольно простой, и многие места реализованы упрощенно. Но все это работает. И можно сказать, оригинально, просто и изящно.

Осмотр закончен. Теперь хорошо бы все это представить на диаграмме чтобы было понятно, как все это работает. И как можно сделать лучше.

+++Исходные файлы проекта
++++Тодо файл
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/Todo.txt] 

++++Первичный алгоритм
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/Program.cs]
* Тут перехватываются исключения и записываются в Лог. Затем приложение завершается.
* Действия:
    * Открывает лог на запись.
    * Создает объект Движка, передает в него объект лога.
    * Инициализирует Движок.
    * Запускает *цикл приема запросов* Engine.ProcessLoop().  Этот цикл ожидает, принимает и исполняет [Команда]ы пользователя. Он завершается по [Команда]е пользователя, возвращает значение завершения Движка. Это значение используется при завершении работы приложения и компьютера.  Просто выключить приложение, выключить компьютер, перезагрузить компьютер, усыпить, гибернация.
    * Деинициализация Движка
    * Записывает в лог сообщение о завершении сессии
    * Закрывает лог
    * обработать требование завершения работы перед самым закрытием приложения: PowerManager.ProcessExitCode(m_exitcode);
    * конец
* Замечания: 
    * Тут лог представлен просто одним пополняемым файлом лога, без ограничения размера и прочего сервиса. Зато в нем отмечены сеансы работы по дате начала сеанса. Конечно, Лог надо существенно переработать и улучшить функциональность. Ввести выделенный каталог лога, ограничение размера лога, множество файлов лога итд. Но не увлекаться функциональностью лога.
    * Важно что Лог запускается раньше чем создается и запускается весь Движок. И закрывается самым последним. Но лог также передается в Движок для использования там.
    * В Лог записываются также исключения при работе Движка. Они тут и перехватываются. 
    * Выключение, перезагрузка компьютера приводят к остановке Оператора. Поэтому они должны именно так и запускаться. Следовательно, показанный тут [Алгоритм] можно перенести и в новый прототип, изменив только некоторые части - лог, сеансы итд.
    * Наверно, класс Лога придется увязать с Настройками (Лог же должен получить из Настроек путь для файла лога), но сделать отдельным от Движка. Так же передавать его в Движок, как это сделано в этом [Алгоритм]е.
        * Можно Лог и Настройки вставить в некий стартовый класс Стартер. Частью этого класса будет и собственно Движок, создаваемый позже.
        * Стартеру нужен путь к файлу Настроек. Или к файлу БД, если все Настройки хранятся в БД.

++++Класс Движок
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/Engine.cs]  
* содержит коллекцию [Процедура]
* содержит коллекцию [Место]
* содержит Лог получаемый конструктором класса Движка.
* Инициализация
    * выводит описание приложения
    * выводит подсказку способа завершения приложения
    * выводит сегодняшнюю дату и время
    * выводит в лог сообщение о начале сеанса
    * заполняет коллекцию [Процедура] зашитыми в код объектами [Процедура] FillHardcodedProcedures() Поскольку БД нет.
    * заполняет коллекцию [Место] вшитыми в код объектами [Место]. Поскольку БД нет.
    * конец
* Деинициализация - пока пусто.
* ProcessLoop()
    * в бесконечном цикле:
        * выводит приглашение ввести [Команда]у
        * читает строку [Команда]ы с консоли, убирает пробелы с концов строки.
        * выводит в лог текст [Команда]ы
        * если [Команда]а соответствует шаблонам [Команда] для выключения, перезагрузки, завершения сеанса, завершения приложения, засыпания, то цикл прерывается и возвращается одно из значений завершения работы ProcedureResult.
            * Засыпание тоже завершает приложение. Хотя это странно, почему так сделано? 
            * Для [Команда] завершения работы и перезагрузки принято запрашивать подтверждение. А тут этого нет. Это должно быть сделано в виде диалога с пользователем.
            * Эти [Процедура]ы должны быть реализованы как полноценные [Команда]ы. А тут они просто наскоро вставлены в основной цикл приема [Команда].
        * выполняется поиск [Команда] перебором,  вызовом result = DoQuery(текст [Команда]ы)
        * если результат - перезагрузка, выключени или выход пользователя, то цикл завершается с соответствующим ProcedureResult. Если же любой другой результат - цикл продолжается.
            * Это позволяет выключать и перезагружать компьютер в результате исполнения [Команда]ы из Коллекции [Процедура], а не непосредственным вводом [Команда]ы, который выше реализован.
            * Это например для [Команда] типа Сделать и выключить, Установить и перезагрузить.
    * Замечания:
        * Надо придумать как реализовать ввод [Команда]ы. Она явно будет однострочной - оканчиваться Enter. Но можно сделать ее многострочной - оканчивать например, Ctrl+Enter. Если это еще не занято чем-нибудь системным. Или можно вводить [Команда]у по нажатию кнопки на форме чата, но это неудобно - пользователю надо переключаться на мышь.
        * Сложность с вводом [Команда]ы в том, что надо отделять введенный текст от предыдущего текста. Но это вполне можно сделать на основе позиций текста. Это я уже делал. Даже можно ввести фишки Терминала: повтор предыдущих [Команда] выбором через клавиши Up Down итд. Но это уже относится к реализации ГУЯ. 
        * Еще одна сложность в том, что ввод [Команда]ы это событие, и его надо ожидать от пользователя. Это я тоже уже где-то реализовывал. Получается очень многопоточное приложение.        
* DoQuery(string query) - исполнить [Команда]у пользователя
    * Для каждой [Процедура]ы в коллекция [Процедура]:
        * MakeNormalRegex(p); - собрать нормальный регекс для данной [Процедура]ы
        * выполнить регекс и определить, является ли [Процедура]а пригодной для исполнения
        * извлечь аргументы из [Процедура]ы и из текста [Команда]ы 
        * Запускаем [Процедура]у. Она должна теперь проверить свои аргументы и все условия, и если не подходят, то завершиться с флагом ProcedureResult.Failed. 
    * Если ни одной [Процедура]ы не найдено, выводим сообщение что для запроса не удалось подобрать [Процедура]у.
    * Если возвращаем ProcedureResult.Success то цикл исполнения [Команда] должен продолжать работу. В прочих случаях цикл должен завершить работу.     
* string MakeNormalRegex(Procedure p) - возвращает нормальный регекс для [Процедура]ы. 
    * определить тип регекса вызовом RegexManager.determineRegexType(p.Regex)
        * Если регекс нормальный, вернуть его копию.
        * Если регекс упрощенный, вызвать RegexManager.ConvertSimpleToRegex2(p.Regex)
        * Если регекс не распознан, выбросить исключение Неправильный регекс в [Процедура]е.
    * Замечания:
        * Регекс в [Процедура]е может быть описан упрощенно или задан нормальной строкой регекса. Упрощенная версия регекса позволяет задавать его пользователю без понимания регекса. Нормальная версия регекса нужна здесь для разных тонкостей в обработке.
* ProcedureResult Execute(string command, string regex, Procedure p, ArgumentCollection args) - выполнить [Процедура]у.
    * сопоставляет аргументы и [Место]а вызовом TryAssignPlaces(args);
    * определяет путь исполнения [Процедура]ы - это приложение или [Процедура]а вызовом RegexManager.IsAssemblyCodePath(p.ExecutionPath)
        * если к приложению, его надо запустить и вернуть стандартное значение для продолжения работы. RunShellExecute(p, args);
        * если к [Процедура]е, надо приготовить аргументы, найти сборку, вызвать функцию, передать ей аргументы и вернуть результат. RunLocalAssembly(command, p, args);          
* ProcedureResult RunLocalAssembly(string command, Procedure p, ArgumentCollection args) - Запустить функцию из локальной сборки    
      * получить имена частей пути. в порядке: сборка, класс, функция, аргументы по порядку следования если они есть RegexManager.ParseAssemblyCodePath(p.ExecutionPath);
      * вызвать [Процедура]у из сборки: result = p.invokeProcedure(command, names, this, args);
* ProcedureResult RunShellExecute(Procedure p, ArgumentCollection args) - Запустить исполнение через ShellExecute механизм.
    * Тут перехватывается исключение, которое возникает при ошибке в ShellExecute.
    * Тут готовится [Команда]ная строка для приложения и потом отсылается в PowerManager.ExecuteApplication(cmdline);
* TryAssignPlaces(ArgumentCollection args) - Сопоставить данные аргументов и [Место]а из коллекции [Место], насколько это возможно.
    * тут надо если у аргумента название есть в словаре [Место], то скопировать в аргумент значение этого [Место]а, пока без проверки типов и всего такого, так как это должна бы делать [Процедура]а.
    * Для каждого аргумента в коллекции аргументов искать значение в коллекции [Место] (перебором коллекции если она - список или как-то еще, если она словарь). Если [Место]о по имени - значению аргумента найдено, то оно (место) вписывается в аргумент: ТипМеста и ЗначениеМеста. 

++++Класс Менеджер регексов
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/RegexManager.cs]
    * почти все функции регекса вынесены в собственный класс регексов. Так с ними проще возиться потом - не искать по всему проекту.
    * RegexType determineRegexType(String pattern) - Определить тип регекса, содержащегося в переданной строке
        * Если первый символ регекса ^ а последний $, то это нормальный регекс.
        * Если нет ни там ни там, это простой регекс
        * Если строка пустая, это пустой регекс
        * Иначе это неправильный регекс.
        * Замечание: Все это примитивно, но пока работает.
    * ConvertApplicationCommandString(String cmdline, ArgumentCollection arguments) - Замена аргументов командной строки приложений.
        * Чудо-штука превращает командную строку в регекс. Как-непонятно.
    * string ConvertSimpleToRegex2(string rx) - Конвертировать простой шаблон в регекс, сохраняя названия аргументов 
        * Название аргумента имеет первый символ %, вот вместо него и имени аргумента вставляется паттерн для регекса, позволяющий выцепить значение аргумента в отдельную регекс-группу.
    * string[] ParseCommandLine(string cmdline) - NT-Разделить строку запуска приложения на путь приложения и аргументы. Поддерживаются только exe и com расширения файлов приложений. И запуск файлов без аргументов. И URI.
        * Замечания: Это корявый способ запуска приложений, и тут надо еще поработать. Тут приложение опознается по расширению первого файла. Если такого расширения нет в собственном списке функции, то опознаваться не будет. Хорошо, что только приложения и батники запускаются с аргументами. Вот их расширения и перечисляются тут.
            * Можно такой список расширений вынести в начало класса или в Настройки Движка. 
            * Код функции не оптимальный, и возможно не все варианты входных данных корректно будут работать. Надо это специально тестировать. 
    *  IsAssemblyCodePath(String path) - Проверить что это путь к сборке кода.
    *  string[] ParseAssemblyCodePath(string path) - разделить путь сборки на имена частей и имена аргументов.
        * разделяет путь к сборке подобный Тапп, на массив строк: сборка-класс-функция-аргумент-аргумент...
    * ArgumentCollection ExtractArgumentsFromCommand(string command, string pattern) - Извлечь аргументы из текста [Команда]ы, если она совпала с шаблоном. Возвращает список аргументов или нуль если не было совпадения.
        * Замечания: Вот так для каждой [Команда]ы приходится делать кучу регексов, а [Команда] может быть сотня. Это начнет тормозить в будущем, и ничего с этим сделать пока нельзя.
    
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/RegexType.cs]
    * енум результатов определения типа [Процедура]ы.  
++++Классы аргументов
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/ArgumentCollection.cs] 
    * Класс КоллекцияАргументовПроцедуры. 
    * Реализована как список, это вполне удобно, поскольку аргументов обычно меньше 10 штук. 
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/FuncArgument.cs]
    * класс АргументПроцедуры
    * Поля:
        * String Тип места или тип данных аргумента
        * String Название аргумента
        * String Значение аргумента 
    * Замечания:
        * Можно добавить ToString() для просмотра в отладчике. 
++++Классы типов сущностей
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/EntityType.cs]
    * описывает класс сущности для семантического анализа.
    * набор функций не лаконичен, можно бы переделать на более адекватный.
    * Это сложная запись классов сущностей для семантической проверки, которая пока не производится.
    * Эти объекты образуют целое дерево классов. Но их вводит пользователь при создании [Место]а. Так что тут может быть много проблем из-за ошибок или неверных представлений пользователя. Тут много философии.
    * Вообще, эту часть надо или автоматизировать, или сильно упростить, или еще что-то придумать - она же не используется сейчас. Семантические проверки аргументов должны были проводить сами [Процедура]ы, после чего отказываться от выполнения работы. Я не помню, реализован ли этот механизм.
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/EntityTypesCollection.cs]
    * словарь классов сущностей для использования в разных местах кода
    * сейчас содержит парсер выражения описания классов сущностей. Парсер протестирован, работает.
    * набор функций не лаконичен, можно бы переделать на более адекватный.

++++Классы Мест 
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/Place.cs]
    * представляет используемую пользователем сущность, например, определенное [Место].
    * Поля:
        * public int Id - первичный ключ таблицы
        * public string Title - уникальное название [Место]а - строка. До 255 символов.
        * public string PlaceTypeExpression - ТипМеста - как класс сущности - аргумента для семантической проверки. До 255 символов.
        * public string Description - описание - текстовое описание для разработчика, в работе не участвует. До 255 символов.
        * public string Path - Веб-путь к сущности [Место]а. До 255 символов.
        * public String Synonim - синонимы - для поддержки множественных названий одной сущности. До 255 символов.
        * public EntityTypesCollection EntityTypes - Дерево типов сущностей
            
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/PlacesCollection.cs] 
    * Словарь, в котором каждому из синонимов Сущности [Место]а сопоставлен объект [Место]а. 
    * Замечания: 
        * На каждое [Место] приходится 6 словоформ падежных. Так словарь быстро разрастется до существенных размеров. Но все равно останется быстрым.
        * Это можно перенести в таблицу БД, с поиском по индексу. На каждую строку своя словоформа. А не держать все в памяти.
        * *Важно!* Одинаковые словоформы конфликтуют и не должны допускаться. Надо проверять [Место]а на уникальность синонимов-словоформ по всему списку [Место]. При создании [Место]а.
        * Конечно, [Место]о должно иметь уникальное название.  

++++Классы [Процедура]
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/Procedure.cs]
    * представляет [Процедура]у.
    * Поля:
        * public int Id - первичный ключ таблицы
        * public String Title - название [Процедура]ы - для пользователя как разработчика [Процедура]. До 255 символов.
        * public Double Ves - порядковый номер проверки в очереди проверок для [Команда]ы - для поддержки очередность проверки выражений
        * public String Regex - регулярное выражение - для проверки соответствия [Команда]ы и [Процедура]ы. До 255 символов.
        * public String ExecutionPath - название запускаемой [Процедура]ы - для запуска [Процедура]ы. До 255 символов.
        * public String Cmd -  исходное выражение  - для разработчика - для визуального примера или тестирования. До 255 символов.
        * public String Descr - Описание - текстовое описание для разработчика.
    * Функции:
        * Функции загрузки сборок кода для исполнения - хорошо бы их перенести в отдельный класс. Особенно потому что из Сборок еще надо ресурсы загружать - справку и картинки итд. И в отдельный домен .NET, чтобы сборки потом выгружать можно было.
        * Функция предикат сортировки [Процедура] по весу.  
           
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/ProcedureAttribute.cs]
    * Атрибут для пометок сборок, классов и функций подобно механизму Тапп1  
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/ProcedureList.cs]
    * класс списка [Процедура], раз уж они в памяти будут храниться а не в БД.
    * Не хватает ТоСтринг() для облегчения отладки.
    * Очевидно, его можно заменить на таблицу [Процедура] в БД и адаптер этой таблицы. Но вот перебор [Процедура] неудобен в этом плане - придется все [Процедура]ы загружать, или же перебирать их особенным образом - только требуемые поля. (А нет, надо все равно загружать и [Процедура]у и ее тело - в последнюю очередь проверок.)  
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/ProcedureResult.cs]
    * енум кода завершения [Процедура]ы. 

++++Управление питанием компьютера
* [file:///V:/МоиПроекты/РечевойИнтерфейс/VisualStudio/SpeakIfaceTest1/SpeakIfaceTest1/PowerManager.cs]
    * Статические Функции:
        * Выключить компьютер
        * Перезагрузить компьютер
        * гибернация
        * Усыпить компьютер
        * Завершить сеанс пользователя компьютера
        * Выполнить приложение по командной строке с аргументами через ShellExecute.    