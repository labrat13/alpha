++ Проблема Автоподстановки Мест
Этот недостаток - продолжение достоинств Мест в Операторе.

Суть проблемы:
Приложение или процедура получает адрес Места вместо текста аргумента, если текст аргумента совпадает с одним из синонимов Места.
Сначала так и задумывалось, для использования Мест вместо адресов файлов и подобных случаев.
Но  оказалось, что иногда нужно вводить текстовые значения, и они не должны преобразовываться в Места. Например, это названия новых заметок, файлов, итп - сейчас Движок заменяет их Местами. И потом код не может получить исходный текст аргумента до замены его на Место. Поскольку поля Класс и Значение в аргументе заменяются на соответствующие значения Места. 

+++Для процедур - успешно решено костылем
Как первое средство, в класс FuncArgument было добавлено поле, хранящее сырое значение аргумента до замены его автоподстановкой Места. Также, в класс FuncArgument было добавлено поле, содержащее копию объекта Места, которое было подставлено Движком. И функция-флаг, что была подстановка Места.
И были внесены изменения в функции Движка, чтобы использовались эти поля.
- теперь в коде процедуры можно сравнительно легко:
-- определить что была подстановка Места
-- получить значение текста аргумента до подстановки Места.
-- получить значение аргумента с или без подстановки Места.
-- получить копию свойств подставленного Места для более лучшей работы с ним.

На эту схему были переделаны существующие процедуры. В результате код работы с аргументами упростился.
Процедура рассчитана на определенное поведение и определенный формат входных данных. Поэтому в ней легко провести нужные проверки и обойти проблему автоподстановки Мест, если это вообще возможно. 

+++Для утилит - проблема!
Утилиты командной строки не обладают таким интеллектом, как процедуры кода, и не могут обойти автоподстановку Места.
Это случай, когда текст, передаваемый в утилиту, совпадает с синонимом какого-либо Места. 
 Например, если есть Место Слон, то нельзя в wget скачать файл с названием слон - вместо аргумента - текста "слон" утилите будет подставлен путь Места Слон. 
 И никак пользователю это не обойти.
 А Мест предполагается очень много в Операторе. И вот это проблема!

++++Костыль
Пока можно только предложить оборачивать такие утилиты в процедуры, и там уже кодом анализировать аргументы и проверять их типы и автоподстановку.
Но это не получается простым! Вот засада, и ее костылями пока закроем.
То есть, команды, которые используют утилиты командной строки, и которые имеют аргументы, которые не могут быть Местами, должны оборачиваться в процедуры, где эти аргументы будут кодом же проверяться на автоподстановку Мест и она будет отменяться.
Это сильно усложнит добавление новых команд в Оператор, так как для каждой утилиты придется выяснять, надо ли ее оборачивать, и затем собственно оборачивать в процедуру. 

+++Обсуждение проблемы
Надо как-то понимать, когда надо подставлять места в аргументы команды, а когда нет.
- семантически размечать саму команду, задавая типы аргументов? Хранить типы аргументов для команды? ЯХЗ, надо думать над этим.
Нужен реальный пример случая! много разных.
- и еще, есть случаи, когда в команде и места могут использоваться, и текстовые (как это называется). И это нормально. Как этот случай распознавать?
-- как это делается в обычном диалоге людей? Надо распознавать омонимы аргументов и спрашивать, что имеется в виду.
   Эта проблема совершенно обычная для таких диалогов. Ну, еще можно запоминать выявленный выбор аргументов, и потом применять его автоматически. Или запоминать правила, условия отбора аргументов, и по ним уже потом работать.
Только хранить эту кучу данных можно только в Тапп - только там достаточно свободы и объема привязываемых данных.
Так что это все откладывается на релиз Оператора с Тапп. Хотя материалы к этому надо собирать уже сейчас.

- а, проблема в том, что традиционно я сначала использую пути сущностей, потом придумываю им названия, так получаются Места. И в дальнейшем пользуюсь этими Местами, которые я помню.
- а тут я сразу Места завел и сильно увлекся их сложностью и основопологательностью. И их трудно создавать, поэтому они не такие легкие в обращении, как в жизни. В жизни-то эти Сущности быстро изменяются: появляются, исчезают, меняют класс, меняют применение, итд. В Операторе это все намного медленнее сейчас. Так как все очень формально, очень основательно. Как наука в средние века. Не хватает легкости и изученных, отработанных решений для обычных задач с Сущностями.
- но места не становятся самоСущностями - это все равно ярлыки для обозначения в речи. И если они неправильно поняты собеседником, надо просто указать на это. Только это должна сделать слушающая сторона, выявив наличие омонимов, возможность конфликта по названиям и конфликта по классам Сущностей. Тогда она должна задать уточняющие вопросы, и говорящая сторона должна выбрать, указать, какую Сущность нужно использовать. И уточнить: всегда или только в этот раз.
Вот эти данные надо запомнить, сопоставить с командой, и в дальнейшем использовать.
-- это получается, к команде еще надо хранить допустимые типы аргументов, историю использования, правила-условия на аргументы, ияхз что еще. И это все надо вводить вместе с командой, или накапливать постепенно по мере использования команды. Это вот часть обучения, для Оператора такая же как для человека. Для этого нужна поддержка в архитектуре системы, иначе это все будет слишком сложным для пользователя.
- и вся эта эпопея дополнительных вопросов ничего не дает мне, кроме лучшего исполнения команд в тех случаях, когда Места конфликтуют с новыми Сущностями, не оформленными в Места. Стоит ли оно того, если Оператор все равно пока ничего полезного делать не может? Разве что как научный проект, на будущее.
-- можно в настройках Оператора хранить флаг: работать с этими проблемами Мест, чтобы накапливать опыт применения команд, или игнорировать проблемы, просто используя накопленный опыт. Это такой переключатель Обучение-Работа.
-- так надо Оператор загрузить полезными функциями. А то он сейчас ничего полезного не делает. Даже себя не обслуживает.

+++Частичные выводы:
* Надо семантически анализировать команду после выделения из нее аргументов, но до вызова исполнения процедуры/утилиты.
    * Это сложно, так как сейчас сама процедура определяет, подходит ли ей этот запрос и набор аргументов или нет. И если нет - движок ищет другую процедуру для данной команды.
    * Если выявлен конфликт автоподстановки Мест, пользователь должен его разрешить. Оператор должен запомнить решение и применять его в дальнейшем. Но и тут есть сложности. 
* Эту тему можно будет решить только после внедрения Тапп в Оператор. До этого времени следует эту тему отложить.
* Сейчас система примитивная, и я не могу хранить классы данных аргументов процедуры. Поэтому семантическую разметку процедур и утилит не получится реализовать сейчас. Чтобы по ней определять, можно ли подставлять Место, или нет.
    * И даже с такой разметкой проблема не будет решена окончательно: есть случаи, когда Места надо подставлять, есть случаи, когда не надо.
* Надо лучше изучить работу с Местами, их жизненный цикл, сделать легким их использование и изменение в Операторе.
* Вся эта возня с Местами только добавляет проблем пользователю. Надо загрузить оператор полезными функциями, чтобы решить, оправданно ли возиться с этими сложностями. 
* Можно сделать флаг Обучение-Работа в настройках Оператора, чтобы управлять количеством этой возни с Местами.   
 
