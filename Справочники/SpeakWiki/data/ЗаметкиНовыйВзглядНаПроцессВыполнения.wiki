++ Заметки Новый Взгляд На Процесс Выполнения

Это решение [Задача]и как пути в некотором графе состояний и операций, в котором пользователь задает начальную точку, но неизвестно, где конечная точка, в которой пользователь прекратит эту работу. И эту конечную точку можно предположить, исходя из первоначальной точки и предыдущих маршрутов в этом графе.
Система должна хранить все предыдущие опыты - проходы по графу, и статистически их обрабатывать. Представлять свое текущее положение в графе и маршрут, по которому в этом графе возможно двигаться дальше.
Надо хранить в доступном для понимания виде все предыдущие работы. Аргументы операций, значения - все, весь поток наблюдения.


Все начинается с начала сеанса работы и заканчивается закрытием этого сеанса работы.
Система должна записывать каждый процесс выполнения [Задача]и. Отдельно от остальных, независимым куском и где-то хранить. В этом куске должны быть представлены все операции и аргументы и события рабочего процесса интерпретатора.
У нас имеется пользователь, исполнитель-интерпретатор и собственно агент речевого интерфейса - Оператор.

+++Статистическое накопление опыта
Эта выполненная [Задача]а должна храниться где-то в системе. И она должна статистически обрабатываться таким образом, чтобы имея 3 однотипных опыта решения [Задача]и, с однотипными операциями, но разными аргументами, система могла их из общей кучи выбрать как одинаковые, и у них разные аргументы. Как в примере программы копирования файла, где одна и та же [Команда]а, но разные имя файла и папка назначения. 
Места, возможно мы будем снабжать речевыми ярлыками - названиями. Чтобы не перечислять весь путь к папке, а сразу назвать конечную папку как конечное [Место]. Это не папки, а именно места. Правда, тогда туда мало что поместится, и надо полагать что это не папка в классическом понимании, в которых пользователь самостоятельно орудует, а такие тематические хранилища, которые пользователь называет, но сам туда не залезает. Файлы там ищет программа.
Такое хранилище содержит больше файлов чем обычная папка, и пользователь не помнит, как файлы называются и что они там вообще есть. Этим всем занимается именно Оператор. Он не только создает файлы и папки проектов, но и удаляет устаревшие, ненужные, архивирует, и проводит инвентаризацию этих проектов. Пользователь, скорее всего, заблудится в этой системе файлов и испортит ее структуру.

Хотя вот классические виндовые [Место] Музыка Фильмы Документы плохи тем, что в них нельзя добавлять или создавать произвольные файлы из-за ограничений уникальности имен файлов. Это все еще папки, которыми заведует пользователь. Я мог бы попробовать сделать из каждого такого [Место] именно хранилище, со своим модулем файлового хранилища. В котором файлы раскладываются по папкам так, что пользователь не сможет их быстро найти. Зато их больше туда помещается и нет ограничений на имена файлов.
Эту тему - Организация и свойства [Место] - надо обдумать отдельно.
Жаль что я не тони старк, чтобы тупо нанять людей сделать эту аналитику темы. Самому это делать долго.


Эта штука вообще состоит из пользователя, оператора, чата между ними, исполнителя - интерпретатора.
Исполнитель должен обеспечивать доступ оператора и пользователя к внутренним данным - объектам, переменным, свойствам объектов.
Скрипт задается пользователем или оператором через чат и запускается на исполнение. Так же на исполнение запускаются сторонние приложения, подобно [Команда]ам командной строки.
Также у оператора должен быть лог всех этих работ, которые проводит оператор или пользователь. Так пользователь обучает оператора. Еще оператор должен проводить статистическую обработку этих своих знаний. Все эти задания в пределах сеанса, в виде подробного лога. Чтобы можно было провести их анализ, статистическую обработку, распознавание каждой работы как последовательности операций. Распознавание по последовательности операций и распознавание по использованию аргументов. Чтобы можно было быстро найти все операции, которые проводились с папкой Мои документы или с каким-то файлом.
И механизм статистического анализа всех этих работ, который должен выявлять шаблоны. Шаблоны это такие часто встречающиеся задания, практически одинаковые по операциям, разные только в аргументах. На основе этих совокупностей похожих заданий он будет формировать шаблоны, которые нуждаются в подтверждении. Подтверждении о том, насколько они соответствуют намерениям-ожиданиям пользователя.
То есть, надо не только отобрать из кучи выполненных заданий несколько похожих, и из них создать шаблон, надо его еще экспериментально проверить, чтобы убедиться, что пользователь хочет именно это.
Шаблоны будут проще, так как они есть абстракция сходных операций. Но эта абстракция должна иметь ссылки на все свои родители - [Задача]и, из которых она образована. И части этого шаблона тоже должны иметь ссылки на свои части-родители в каждой из родительских [Задача].
То есть, для каждой детали этого шаблона [Задача]и можно было бы найти по ссылкам те детали, из которых она была абстрагированием создана.  
Шаблон является классом [Задача]и, а сами [Задача]и и их части будут объектами. И шаблон состоит из классов операций итд.
Шаблон утверждается пользователем. Или не утверждается. Затем по нему идет работа. То есть, поступающие [Команда]ы и данные интерпретируются в соответствии с этим шаблоном.
Крме того случая, когда пользователь явно желает сменить шаблон, заявляет что это неправильно. 
Тут надо, чтобы пользователь знал, что он собирается делать и как это называется. 
И чтобы можно было бы все выполненные операции откатить или отменить и заново сделать. Но это не всегда возможно. Вот это надо предусматривать.
Шаблон получается вовсе не одним таким независимым файлом. Он получается сетью из объектов, классов объектов. В этом [Алгоритм]е могут быть различные отклонения, ответвления. Строго говоря, это не [Алгоритм], это граф из переходов и состояний. В этом графе пользователь прокладывает маршрут как [Алгоритм], в процессе работы над [Задача]ей.
Не то чтобы он сразу прокладывает маршрут... Пользователь обозначает начальную точку и каждый раз выбирает следующую операцию для достижения конечной точки этого саршрута. Эта конечная точка не всегда может быть известна заранее. Каждый такой маршрут остается в памяти вместе со всеми аргументами, и пополняет - подтверждает этот граф.
Получается единый граф из вершин-состояний и дуг - операций. Или сеть петри, где операции это переходы, а комплекты аргументов - эти как их там называются, тумбочки и фишки. Фишки показывают достаточность ресурсов, то есть наличие аргументов для операции. Такая вот штука, непрерывная, и новые опыты в ней не теряются, а встраиваются. Одновременно достраивая граф и сохраняются где-то независимо, как опыт работы. 

Вот это такой получается многослойный граф, где в нижнем слое хранятся наблюдения решенных [Задача], а в более верхнем хранятся созданные из этих наблюдений абстрактные шаблоны, а в еще более верхнем хранятся наблюдения решенных по этим шаблонам [Задача], а в еще более верхних шаблоны решения [Задача] по шаблонам, и так далее.
Такая многослойная схема у меня уже описана где-то. ГДЕ? Еще там около должен быть TimeMachine проект, там что-то схожее. 
Граф показывает оператору варианты, куда может пойти развитие решения. И оператор может эти варианты перебирать для поиска оптимального решения или предлагать пользователю на выбор.

Так как пользователь не в состоянии помнить весь этот граф и свое положение в нем, то это вот ориентирование в графе пользователь может выполнять только с подсказками и выбором вариантов. 
И еще пользователю потребуется восстанавливать контекст, спрашивая у оператора: А на чем мы собственно остановились?  Это надо предусмотреть. У каждого узла в графе должно быть уникальное название, присвоенное пользователем или согласованное с ним. Насколько вообще это возможно.

+++Назначение системы

Этот проект позволяет создать обучающуюся систему, которая может делать за меня некоторые работы.
   
Что это должно мне дать?
Это будет работающая на компьютере практически независимая самообучающаяся штука, которая будет делать для меня какие-то мелкие работы. Может быть, если я это сделаю, эта штука будет писать для меня кусочки программ. Что ускорит разработку новых программ.
А может быть,эта штука сможет для меня отбирать подходящие документы из результатов поиска. 
Для этого всего надо сделать эту чудо-систему. В виде постепенного улучшения, начиная с самой простой версии. Это будет некое первичное средство, первичный опыт, понимание чего нехватает, что как можно реализовать. Одним словом, лучше немного но сегодня, чем больше но завтра.
Сначала это будет примитивная работа, на уровне копирования файла. Может быть, бекап моих проектов. А там потом как получится.
Вероятно, на первое время применений будет мало. Это тормозит все развитие проекта. Так как толку от системы в этом случае тоже немного.
Тут самое главное отработать эту технологию статистического накопления опыта по работам.
Ну и по событиям, реакциям на события. Если потом еще добавить реакции на события, то это будет более-менее полноценная штука. Хотя можно реакции на события - рефлексы - сделать сразу, но они будут безусловными. А нужны условные. 

+++Построение системы
Для начала надо создать некий простой прототип, с которым постепенно наращивать и опыт и материалы и понимание того что и как надо делать, и мотивацию что-то делать. И логи диалогов, которые потом можно сводить в предположения о том как их обрабатывать и как статистический материал для понимания формата, вывода и все такое.
Такой быстро упрощенный прототип, чтобы уже работал,приносил опыт, результаты, давал экономию труда.


