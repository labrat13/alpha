Как реализовать доступ к клипборду для Оператор.
Идеи

Клипборд это Сущность, которая может быть прочитана и записана, не может быть удалена, может быть переименована (?), итп.
В этом она подобна Файлу.
Поэтому проблема с ней в том, что она в концепции представлена как Место.
Место, как Сущность, имеет путь и может быть только прочитано.
Название Места передается в тексте команды, и при исполнении команды оно сейчас используется как приложение или как файл документа итп.
 В общем, используется только для чтения.
А надо как-то использовать ее и для записи, и удаления, и прочих файловых операций. 

А) реализовать процедуры сразу с поддержкой клипборда.
То есть, слово клипборд будет входить в регекс команды.
Это более простой, прямой способ добавить клипборд в Оператор. 
Но придется каждую процедуру так дублировать. Это неправильно.

Б) Зарегистрировать клипборд как Место, и в коде Процедуры караулить это Место и выполнять операции с ним согласно алгоритма Процедуры.
Это потребует писать специальный небольшой код для каждой Процедуры, в которой может быть использован Клипборд.

В)  Зарегистрировать клипборд как Место.
При разборе команды передавать клипборд в Процедуру как объект-Место определенного класса.
Это уже делается, только класс Места сейчас не учитывается.
А надо, чтобы код Процедуры проверял класс Места, по нему определял набор доступных действий, 
  создавал объект-представитель Места и запускал в нем требуемую Процедурой операцию для Места.
Так можно унифицировать Места вроде Клипбоард и Файл и единообразно читать требуемые данные из файла или из Клипборда.  
Это потребует:
- предварительно составить список классов мест, чтобы вносить их в дерево упорядоченно, на этапе внедрения этой фичи с классами Мест.
- хранения дерева классов Сущностей-Мест с указанием пути к коду - объекту-представителю.
  Для каждой Сущности там должны быть указаны операции, чтобы выявлять несоответствия еще до загрузки объекта-представителя.
- создания сборки классов объектов-представителей с функциями для выполнения операций.
  TODO: кто будет создавать такие сборки и дописывать в них код классов?
- пользователь, создавая Место, должен правильно указать его класс, чтобы потом не было проблем.
- код процедуры создания Места должен проверять класс Места, чтобы не допускать запись в исполняемый файл,
  запись в файл-Место только-для-чтения, итп.
- код объекта-представителя должен реализовать корректный отказ при неправильном вызове Места, когда пользователь неправильно указал класс Места при создании Места.
- код Процедуры должен проверять класс Места, чтобы не допускать неподдерживаемую операцию для данного Места.
  При недопустимом классе Места Процедура должна отказаться исполнять команду, чтобы движок искал другую команду для исполнения.
- этот новый метод должен использоваться внутри каждой Процедуры, так что следует разработать АПИ для быстрого и легкого использования.
  Поскольку код Процедур будет писать кто попало.
- для просмотра и редактирования дерева классов нужны команды или специальный ГУИ-браузер дерева классов, вызываемый через Оператор или отдельно.  
- для создания классов Мест нужны Команды создания Класса Места, в которых нужно ввести название класа, описание класса, операци класса, наследование класса, и прочие свойства класса Места.
  Это целый отдельный служебный неймспейс для команд потребуется.
- тогда хорошо бы и классы Команд и Процедур завести и указывать при создании Команд?
  - но это слишком много проблем для Пользователя получится! 
    Ему же надо эти классы выбрать и ввести по памяти, без подсказок.
    А нужно освободить Пользователя от таких затруднений.	
Это похоже на реестр виндовс с его классами и интерфейсами, только тут попроще.

Выводы:
- Вариант Б) можно внедрить в Оператор прямо сейчас, но в будущем придется переделывать использующие его Процедуры.
  - а Процедуры все равно переделывать при каждом изменении архитектуры Оператора.
    - TODO: вот это плохо, надо как-то уменьшить количество работы по переделке Процедур.
- Вариант В) самый лучший, но сложный, требует добавления в Оператор множества новых частей.
  И много всего надо изобрести.
  Зато этот механизм позволяет осуществить поддержку операций с файлами и дисковыми томами, портами ввода-вывода и прочими устройствами компьютера.
  Надо еще создать код (класс) объекта-представителя для этих объектов и добавить их в дерево классов Оператор.
  А потом можно писать Процедуры для Команд с такими Местами.  
  

