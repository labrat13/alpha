Тут надо описывать процесс добавления в Оператор команд создания мест и процедур.

Я забросил Оператор на три года.
Я рассчитывал, что буду добавлять в него команды по мере возможности. Но в итоге так ничего и не добавил.
Почему?
- а вот никак! 
-- команду можно добавить, если есть потребность в некоторой процедуре, и она возникает часто, и она представляет собой запуск одной программы из командной строки, и эта команда делает всю работу. Ну или показывает окно, в котором можно сделать всю работу. Такая команда-ярлык. А у меня или уже все такие процедуры отработаны, реализованы ярлыками, или они слишком вариативные, или редко требуются.
Значит, Оператор надо развивать, чтобы увеличить число команд и повысить степень использования Оператора. Развивать в плане его возможностей работы с оборудованием.

Так, что представляют собой команды для Процедур и Мест?
- Команды создания 
- команды удаления
- команды просмотра списка
- команды редактирования

Эти процедуры должны быть встроены в Оператор.
Но сейчас я не могу реализовать такую встроенность - сейчас процедуры должны размещаться в внешних сборках и быть помечены специальным атрибутом.
Реально встроенные процедуры - завершения программы - встроены на уровне кода.
А все другие я не хочу так встраивать - это не гибко.
Поэтому для процедур работы с местами и процедурами придется создать отдельную сборку для встроенных процедур. 

Возвращаемые значения:
Процедуры должны возвращать значение: 
- ProcedureResult.Success если все успешно, 
- ProcedureResult.WrongArguments если запрос не подходит для данной процедуры,
- ProcedureResult.Error если при выполнении процедуры возникла ошибка.
  и другие коды результатов см енум ProcedureResult.


Адаптер БД:
+ содержит функции выборки записей процедур и мест
+ содержит функции добавления записей процедур и мест
- не содержит функции удаления  записей процедур и мест - надо добавить
- не содержит функции изменения записей процедур и мест - надо добавить
-----------------------------------------------------------------------------------
Свойства Мест:
- int Id - первичный ключ таблицы

- string Title - уникальное название места - строка. До 255 символов. Индексированное.
-- Проверять, что название уникальное, без учета регистра символов.
-- Обычно сразу задается в команде как аргумент.

- string PlaceTypeExpression - Тип места - как класс сущности - аргумента для семантической проверки. Длина любая. Поле MEMO в БД. Специальный формат!
-- Требует справочника по классам мест, а его пока нет. Надо создать такой справочник.

- string Description - описание - текстовое описание для разработчика, в работе не участвует. Длина любая. Поле MEMO в БД.

- string Path - Веб-путь к сущности места. Длина любая. Поле MEMO в БД. Специальный формат!
-- надо уточнить и проработать формат этого пути и работы с ним.
- аргумент %arg не должен содержать пробелы в имени (Неправильно: %arg 1). Иначе он будет неправильно распарсен кодом.

- String Synonim - синонимы - для поддержки множественных названий одной сущности. Длина любая. Поле MEMO в БД. Специальный формат!
-- Перечисление синонимов через , или ;
-- обычно это 6 падежных форм.
-- Синонимы и словоформы должен вводить пользователь. Ему предлагается шаблон-подсказка, чтобы проще было вводить падежные формы.
-- словоформы разных Мест не могут совпадать сейчас. Надо проверять, чтто синонимы создаваемого Места не пересекаются с уже существующими.

- EntityTypesCollection EntityTypes - Дерево типов сущностей, заполняется, но сейчас не используется.


Пример заполнения:
            p = new Place();
            //заполнить вручную поля
            p.Title = "Браузер";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "браузер, браузера, браузеру, браузером, браузере";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Программа веб-браузера как место";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "C:\\Program Files\\Internet Explorer\\iexplore.exe";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Приложение::ВебБраузер<Файл::ФайлHtml, ВебАдрес>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.AddPlace(p);//добавить строку

-------------------------------------------------------------------------------------------------------------------------

Свойства Процедур:
- int Id - первичный ключ таблицы

- String Title - название процедуры - для пользователя как разработчика процедур. До 255 символов.

- Double Ves - порядковый номер проверки в очереди проверок для команды - для поддержки очередность проверки выражений
-- Вес процедуры: 0 - самая первая к исполнению, самая детальная (Пример: Открыть панель управления); 1 - самая последняя, самая абстрактная (Пример: %место)

- String Regex - регулярное выражение - для проверки соответствия команды и процедуры. До 255 символов.

- ExecutionPath - название запускаемой процедуры - для запуска процедуры. До 255 символов.

- String Cmd - исходное выражение  - для разработчика - для визуального примера или тестирования. До 255 символов.

- String Descr - Описание - текстовое описание для разработчика.

 Примеры:
 
 Запустить процедуру из подключаемой сборки:
             p = new Procedure();
            //заполнить вручную поля
            p.Title = "Тест эхо";//Название процедуры, в работе механизма не используется
            p.Cmd = "Тест эхо";//Текст запроса пользователя, в работе механизма не используется
            p.Regex = "тест эхо";//Регулярное выражение, простое или сложное.
            p.ExecutionPath = "FirstProcedures.Procedures.CommandHandlerExample()";//Путь к функции в сборке или к приложению, может содержать аргументы.
            p.Descr = "Тестирование вывода на консоль из загружаемого обработчика команды";//Текст описания сущности, не обязателен, в работе механизма не используется.
            //p.Ves = 0.00;//Вес процедуры
            //добавление в коллекцию
            this.m_proclist.Add(p);
            
Открыть место через шелл:
            p = new Procedure();
            //заполнить вручную поля
            p.Title = "Открыть место";//Название процедуры, в работе механизма не используется
            p.Cmd = "открыть место";//Текст запроса пользователя, в работе механизма не используется
            p.Regex = "открыть %место";//Регулярное выражение, простое или сложное.
            p.ExecutionPath = "%место";//Путь к функции в сборке или к приложению, может содержать аргументы.
            p.Descr = "Тестирование работы с местами";//Текст описания сущности, не обязателен, в работе механизма не используется.
            p.Ves = 0.9;//Вес процедуры
            //добавление в коллекцию
            this.m_proclist.Add(p);

Открыть кастомную веб-ссылку через шелл
            p = new Procedure();
            //заполнить вручную поля
            p.Title = "Найти в Инвентаре";//Название процедуры, в работе механизма не используется
            p.Cmd = "найти в Инвентаре КТ315Б";//Текст запроса пользователя, в работе механизма не используется
            p.Regex = "найти в инвентаре %предмет";//Регулярное выражение, простое или сложное.
            p.ExecutionPath = "inv:\\\\%предмет";//Путь к функции в сборке или к приложению, может содержать аргументы.
            p.Descr = "найти в инвентаре предмет";//Текст описания сущности, не обязателен, в работе механизма не используется.
            p.Ves = 0.50;//Вес процедуры
            //добавление в коллекцию
            this.m_proclist.Add(p);  
-----------------------------------------------

         
-----------------------------------------------
Ход работы и решения:

23 июня 2019
- сейчас надо создать новую сборку для "внутренних процедур" со всеми атрибутами итп, в ней создать класс, в нем создать функции процедур.
Поскольку механизм их вызова уже реализован и проверен, пока в функциях этих поставим вывод сообщений на экран и успешное завершение.
А потом будем проектировать проверки аргументов, проектировать диалог и реализовывать его понемногу.
Там этой работы много мелкой и крупной, сейчас надо создать основы.
+ создан проект библиотеки ProceduresInt
+ создан класс public static class PlaceProcedures для процедур Мест
+ создан класс public static class ProcedureProcedures для процедур Процедур
+ созданы функции-заглушки с выводом текста: 
  ProceduresInt.PlaceProcedures.CommandCreatePlace и ProceduresInt.ProcedureProcedures.CommandCreateProcedure
+ добавлены записи команд в БД
+ Тестирование: надо создать папку в C:\\Temp и скидать в нее обе сборки, БД, екзешник.
  - запустить екзешник и ввести команды:
    Создать место трамвай
    Создать процедуру трамвай
  - результат был успешен - выведен назначенный текст. Обе процедуры вызываются.
Вывод: намеченный результат достигнут. Начальная инфраструктура создана, работает.
  Теперь можно работать над создаием диалога создания процедур и мест.
 - надо придумать, как импортировать места и команды из такой вот сборки. 
    Их же надо при развертывании Оператора создавать в БД. Вручную, через БД - не хочется.
    Надо какую-то фукцию запустить из этой сборки, чтобы она сама внесла в БД свои команды и места.
    Тогда приложение при первом запуске просто все сборки в каталоге сборок переберет, все команды из них загрузит, и все - развертывание выполнено.
    Ну а такая функция в сборке - может и реестр прочитать и сама найти нужные пути и места - сделает всю нужную работу по инициализации сама.
   Вывод: каждая сборка команд должна иметь функцию с фиксированным заголовком, которая выполнит инициализацию-подключение сборки к Оператору.
     - тогда и на отключение (удаление) сборки из Оператора - тоже нужна подобная специальная функция.
     - осталось проверить. возможно ли вообще из сторонней сборки работать с БД Оператора.   
       
24 июня 2019
+ нужен доступ к БД, а она недоступна, так как только при старте открывается, читается в память и закрывается.
  А мне надо добавить в нее процедуру или место.
  - надо сделать БД постоянно доступной через объект движка. Чтобы открывалась при запуске и закрывалась при завершении Оператора.
    Как в моих остальных программах.
  - и надо тогда или каждый запрос делать через БД а не через память, или сделать функцию, которая перезагружает этот кеш процедур и мест из БД.
    И вызывать ее каждый раз после изменения содержимого БД.
    Это будет медленно, но иначе пока никак.   Тут надо всю систему перепроектировать тогда.
    + добавлена функция private void Engine.reloadProceduresPlacesFromDatabase() - перезагружает коллекции из БД.
  - небезопасно давать доступ к БД стороннему коду из сборок...
    - попробую сделать прокси-функции операций с БД в самом движке, а проперти БД спрятать от сторонних сборок.
      Это криво, но пока так.
      - Это потому получается, что кеш-коллекции находятся в движке, а не в адаптере БД, как следовало бы.
        Потому что весь код кривоват и сделан наскоро, лишь бы работало.
        По-хорошему, надо просто сделать набор функций для сторонних сборок прямо в адаптере БД или в выделенном классе-обертке.
  + Вывод: БД теперь постоянно доступна в Операторе, но в сторонние сборки она не доступна - к ней можно обратиться оттуда только через прокси-функции движка.      
+ добавлены функции public void Engine.DbInsertPlace(Place p) и public void Engine.DbInsertProcedure(Procedure p)
  для добавления новых процедур и мест в БД и в Оператор вообще.
  - есть версии этих функций для добавления нескольких элементов сразу.
  - не тестировались пока.
- теперь надо придумать диалог создания места и процедуры
  - проверить уникальность названия и синонимов. 
     Опять же через новые функции движка, которые будут искать пока в кеш-коллекциях, раз уж они синхронизированы с БД.
  - в конце надо собрать все в одно представление и показать пользователю. Если он подтвердит, то записать этот новый объект в БД.
  - TODO: а где у меня наброски этой процедуры? надо найти!                  
  




             